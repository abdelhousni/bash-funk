#!/usr/bin/env bash
#
# SPDX-FileCopyrightText: Â© Vegard IT GmbH (https://vegardit.com)
# SPDX-License-Identifier: Apache-2.0
#
# @author Sebastian Thomschke, Vegard IT GmbH
# @author Patrick Spielmann, Vegard IT GmbH
#
# THIS FILE IS GENERATED BY BASH-FUNK GENERATOR
#
# documentation: https://github.com/vegardit/bash-funk/tree/main/docs/crypto.md
#

function -md5sum() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... PATH_TO_FILE\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-md5sum() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _tracecmd _PATH_TO_FILE
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... PATH_TO_FILE"
            echo
            echo "Calculates the MD5 hash of the given file."
            echo
            echo "Parameters:"
            echo -e "  \033[1mPATH_TO_FILE\033[22m (required, file)"
            echo "      The file."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      if [[ ! $_PATH_TO_FILE ]]; then
         _PATH_TO_FILE=$__param
         continue
      fi
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ $_PATH_TO_FILE ]]; then
      if [[ ! -e "$_PATH_TO_FILE" ]]; then echo "$__fn: Error: File '$_PATH_TO_FILE' for parameter PATH_TO_FILE does not exist."; return 64; fi
      if [[ -e "$_PATH_TO_FILE" && ! -f "$_PATH_TO_FILE" ]]; then echo "$__fn: Error: Path '$_PATH_TO_FILE' for parameter PATH_TO_FILE is not a file."; return 64; fi
      if [[ ! -r "$_PATH_TO_FILE" ]]; then echo "$__fn: Error: File '$_PATH_TO_FILE' for parameter PATH_TO_FILE is not readable by user '$USER'."; return 64; fi
   else
      echo "$__fn: Error: Parameter PATH_TO_FILE must be specified."; return 64
   fi

####### md5sum ####### START
[[ $_tracecmd ]] && set -x || true
# use md5sum if available
if hash md5sum &>/dev/null; then
   md5sum $_PATH_TO_FILE | cut -d ' ' -f1

# use perl if available
elif hash perl &>/dev/null; then
   perl << EOF
use Digest::MD5;
open(my \$FILE, '$_PATH_TO_FILE');
binmode(\$FILE);
print Digest::MD5->new->addfile(\$FILE)->hexdigest, "\n";
close(\$FILE);
EOF

# use python as last resort
else
   python -c "import hashlib
print(hashlib.md5(open('$_PATH_TO_FILE').read()).hexdigest())"
fi
[[ $_tracecmd ]] && set +x || true
####### md5sum ####### END
}
function __complete-md5sum() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}md5sum -- ${BASH_FUNK_PREFIX:--}md5sum

function -sha256sum() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... PATH_TO_FILE\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-sha256sum() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _tracecmd _PATH_TO_FILE
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... PATH_TO_FILE"
            echo
            echo "Calculates the SHA256 hash of the given file."
            echo
            echo "Parameters:"
            echo -e "  \033[1mPATH_TO_FILE\033[22m (required, file)"
            echo "      The file."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      if [[ ! $_PATH_TO_FILE ]]; then
         _PATH_TO_FILE=$__param
         continue
      fi
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ $_PATH_TO_FILE ]]; then
      if [[ ! -e "$_PATH_TO_FILE" ]]; then echo "$__fn: Error: File '$_PATH_TO_FILE' for parameter PATH_TO_FILE does not exist."; return 64; fi
      if [[ -e "$_PATH_TO_FILE" && ! -f "$_PATH_TO_FILE" ]]; then echo "$__fn: Error: Path '$_PATH_TO_FILE' for parameter PATH_TO_FILE is not a file."; return 64; fi
      if [[ ! -r "$_PATH_TO_FILE" ]]; then echo "$__fn: Error: File '$_PATH_TO_FILE' for parameter PATH_TO_FILE is not readable by user '$USER'."; return 64; fi
   else
      echo "$__fn: Error: Parameter PATH_TO_FILE must be specified."; return 64
   fi

####### sha256sum ####### START
[[ $_tracecmd ]] && set -x || true
# use sha256 if available
if hash sha256 &>/dev/null; then
   sha256 $_PATH_TO_FILE | cut -d ' ' -f1

# use perl if available
elif hash perl &>/dev/null; then
   perl << EOF
use Digest::SHA;
open(my \$FILE, '$_PATH_TO_FILE');
binmode(\$FILE);
print Digest::SHA->new(256)->addfile(\$FILE)->hexdigest, "\n";
close(\$FILE);
EOF

# use python as last resort
else
   python -c "import hashlib
print(hashlib.sha256(open('$_PATH_TO_FILE').read()).hexdigest())"
fi
[[ $_tracecmd ]] && set +x || true
####### sha256sum ####### END
}
function __complete-sha256sum() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}sha256sum -- ${BASH_FUNK_PREFIX:--}sha256sum

function -test-all-crypto() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]...\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-test-all-crypto() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _tracecmd
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]..."
            echo
            echo "Performs a selftest of all functions of this module by executing each function with option '--selftest'."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

####### test-all-crypto ####### START
[[ $_tracecmd ]] && set -x || true
${BASH_FUNK_PREFIX:--}md5sum --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}sha256sum --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}verify-tar-md5 --selftest && echo || return 1
[[ $_tracecmd ]] && set +x || true
####### test-all-crypto ####### END
}
function __complete-test-all-crypto() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}test-all-crypto -- ${BASH_FUNK_PREFIX:--}test-all-crypto

function -verify-tar-md5() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... [PATH_TO_ARCHIVE]...\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-verify-tar-md5() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _tracecmd _PATH_TO_ARCHIVE=()
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... [PATH_TO_ARCHIVE]..."
            echo
            echo "Verifies the MD5 sum of tar files with embedded checksum information. Usually Android firmware archives, see https://fileinfo.com/extension/tar.md5."
            echo
            echo "Parameters:"
            echo -e "  \033[1mPATH_TO_ARCHIVE\033[22m (file)"
            echo "      The tar.md5 file."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      _PATH_TO_ARCHIVE+=("$__param")
      continue
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ $_PATH_TO_ARCHIVE ]]; then
      local __param
      for __param in "${_PATH_TO_ARCHIVE[@]}"; do
          if [[ ! -e "$__param" ]]; then echo "$__fn: Error: File '$__param' for parameter PATH_TO_ARCHIVE does not exist."; return 64; fi
          if [[ -e "$__param" && ! -f "$__param" ]]; then echo "$__fn: Error: Path '$__param' for parameter PATH_TO_ARCHIVE is not a file."; return 64; fi
          if [[ ! -r "$__param" ]]; then echo "$__fn: Error: File '$__param' for parameter PATH_TO_ARCHIVE is not readable by user '$USER'."; return 64; fi
      done
   fi

####### verify-tar-md5 ####### START
[[ $_tracecmd ]] && set -x || true
local path mismatch=0
echo "Verifying..."
for path in "${_PATH_TO_ARCHIVE[@]}"; do
   echo -n "$path "
   local embedded_md5=$(tail -1 "$path" | cut -f1 -d' ' | tr '[:upper:]' '[:lower:]')
   local actual_md5=$(head -n -1 "$path" | md5sum | cut -f1 -d' ')
   if [[ $embedded_md5 == $actual_md5 ]]; then
      echo "OK"
   else
      echo "FAILED"
      mismatch=1
      echo "  -> embedded MD5 sum: $embedded_md5"
      echo "  ->   actual MD5 sum: $actual_md5"
   fi
done

if [[ $mismatch == 1 ]]; then
   return 1
fi
[[ $_tracecmd ]] && set +x || true
####### verify-tar-md5 ####### END
}
function __complete-verify-tar-md5() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}verify-tar-md5 -- ${BASH_FUNK_PREFIX:--}verify-tar-md5


function -help-crypto() {
   local p="\033[1m${BASH_FUNK_PREFIX:--}"
   echo -e "${p}md5sum PATH_TO_FILE\033[0m  -  Calculates the MD5 hash of the given file."
   echo -e "${p}sha256sum PATH_TO_FILE\033[0m  -  Calculates the SHA256 hash of the given file."
   echo -e "${p}test-all-crypto\033[0m  -  Performs a selftest of all functions of this module by executing each function with option '--selftest'."
   echo -e "${p}verify-tar-md5 [PATH_TO_ARCHIVE]...\033[0m  -  Verifies the MD5 sum of tar files with embedded checksum information. Usually Android firmware archives, see https://fileinfo.com/extension/tar.md5."
}
__BASH_FUNK_FUNCS+=( md5sum sha256sum test-all-crypto verify-tar-md5 )
