#!/usr/bin/env bash
#
# SPDX-FileCopyrightText: Â© Vegard IT GmbH (https://vegardit.com)
# SPDX-License-Identifier: Apache-2.0
#
# @author Sebastian Thomschke, Vegard IT GmbH
# @author Patrick Spielmann, Vegard IT GmbH
#
# THIS FILE IS GENERATED BY BASH-FUNK GENERATOR
#
# documentation: https://github.com/vegardit/bash-funk/tree/main/docs/network.md
#

function -block-port() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... [BIND_ADDRESS] PORT\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-block-port() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _duration _help _selftest _tracecmd _BIND_ADDRESS _PORT
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... [BIND_ADDRESS] PORT"
            echo
            echo "Binds to the given port and thus block other programs from binding to it."
            echo
            echo "Parameters:"
            echo -e "  \033[1mBIND_ADDRESS\033[22m (default: '0.0.0.0')"
            echo "      The local bind address. E.g. 127.0.0.1."
            echo -e "  \033[1mPORT\033[22m (required, integer: 0-65535)"
            echo "      Number of the port to occupy."
            echo
            echo "Options:"
            echo -e "\033[1m-d, --duration SECONDS\033[22m (integer: ?-?)"
            echo "        Duration in seconds to block the port."
            echo "    -----------------------------"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            echo "Examples:"
            echo -e "$ \033[1m$__fn --duration 1  12345\033[22m"
            echo "Binding to 0.0.0.0:12345...
Press [CTRL]+[C] to abort."
            echo -e "$ \033[1m$__fn -d 1  127.0.0.1  12345\033[22m"
            echo "Binding to 127.0.0.1:12345...
Press [CTRL]+[C] to abort."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn --duration 1  12345\033[22m"
            __stdout="$($__fn --duration 1  12345)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^Binding to 0\.0\.0\.0:12345\.\.\.
Press \[CTRL\]\+\[C\] to abort\.$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [Binding to 0\.0\.0\.0:12345\.\.\.
Press \[CTRL\]\+\[C\] to abort\.]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn -d 1  127.0.0.1  12345\033[22m"
            __stdout="$($__fn -d 1  127.0.0.1  12345)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^Binding to 127\.0\.0\.1:12345\.\.\.
Press \[CTRL\]\+\[C\] to abort\.$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [Binding to 127\.0\.0\.1:12345\.\.\.
Press \[CTRL\]\+\[C\] to abort\.]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 70000\033[22m"
            __stdout="$($__fn 70000)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 64 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [64]."; return 64; fi
            __regex="Error: Value '70000' for parameter PORT is too high. Must be <= 65535."
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [Error: Value '70000' for parameter PORT is too high. Must be <= 65535.]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --duration|-d)
            _duration="@@##@@"
            __optionWithValue=duration
         ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               duration)
                  _duration=$__arg
                  __optionWithValue=
                 ;;
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      if [[ ! $_BIND_ADDRESS && ${#__params[@]} > 1 ]]; then
         _BIND_ADDRESS=$__param
         continue
      fi
      if [[ ! $_PORT ]]; then
         _PORT=$__param
         continue
      fi
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ ! $_BIND_ADDRESS ]]; then _BIND_ADDRESS="0.0.0.0"; fi
   if [[ $_duration ]]; then
      if [[ $_duration == "@@##@@" ]]; then echo "$__fn: Error: Value SECONDS for option --duration must be specified."; return 64; fi
      if [[ ! "$_duration" =~ ^-?[0-9]*$ ]]; then echo "$__fn: Error: Value '$_duration' for option --duration is not a numeric value."; return 64; fi
   fi

   if [[ $_PORT ]]; then
      if [[ ! "$_PORT" =~ ^-?[0-9]*$ ]]; then echo "$__fn: Error: Value '$_PORT' for parameter PORT is not a numeric value."; return 64; fi
      if [[ $_PORT -lt 0 ]]; then echo "$__fn: Error: Value '$_PORT' for parameter PORT is too low. Must be >= 0."; return 64; fi
      if [[ $_PORT -gt 65535 ]]; then echo "$__fn: Error: Value '$_PORT' for parameter PORT is too high. Must be <= 65535."; return 64; fi
   else
      echo "$__fn: Error: Parameter PORT must be specified."; return 64
   fi

####### block-port ####### START
[[ $_tracecmd ]] && set -x || true
echo "Binding to $_BIND_ADDRESS:$_PORT..."

[[ $_duration ]] && local timeout="Timeout => $_duration," || local timeout="";

perl << EOF
   use IO::Socket;
   \$server = IO::Socket::INET->new(
      LocalAddr => '$_BIND_ADDRESS',
      LocalPort => $_PORT,
      Type => SOCK_STREAM,
      ReuseAddr => 1,
      $timeout
      Listen => 10
   ) or die "Couldn't bind to $_BIND_ADDRESS:$_PORT: \$@\n";
   print("Press [CTRL]+[C] to abort.\n");
   while (\$client = \$server->accept()) { }
   close(\$server);
EOF
[[ $_tracecmd ]] && set +x || true
####### block-port ####### END
}
function __complete-block-port() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --duration -d --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}block-port -- ${BASH_FUNK_PREFIX:--}block-port

function -flush-dns() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]...\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-flush-dns() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _tracecmd
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]..."
            echo
            echo "Flushes the local DNS cache."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

####### flush-dns ####### START
[[ $_tracecmd ]] && set -x || true
case $OSTYPE in
   cygwin|msys) cmd="ipconfig /flushdns" ;;
   darwin) cmd="sudo dscacheutil -flushcache; sudo killall -HUP mDNSResponder" ;;
   *)
     if hash systemd-resolve &>/dev/null; then
        cmd="sudo systemd-resolve --flush-caches && systemd-resolve --statistics"
     elif hash resolvectl &>/dev/null; then
        cmd="sudo resolvectl flush-caches && resolvectl statistics"
     elif service nscd status &>/dev/null; then
        cmd="sudo service nscd restart"
     elif [ -f /etc/init.d/networking ]; then
        cmd="sudo /etc/init.d/networking restart"
     elif systemctl &>/dev/null; then
        cmd="sudo systemctl restart networking"
     else
        echo "Unsupported system configuration. Cannot flush DNS cache."
        exit 1
     fi
  ;;
esac
echo $cmd
eval $cmd
[[ $_tracecmd ]] && set +x || true
####### flush-dns ####### END
}
function __complete-flush-dns() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}flush-dns -- ${BASH_FUNK_PREFIX:--}flush-dns

function -is-port-open() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... HOSTNAME PORT [CONNECT_TIMEOUT_IN_SECONDS]\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-is-port-open() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _tracecmd _verbose _HOSTNAME _PORT _CONNECT_TIMEOUT_IN_SECONDS
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... HOSTNAME PORT [CONNECT_TIMEOUT_IN_SECONDS]"
            echo
            echo "Checks if a TCP connection can be established to the given port."
            echo
            echo "Parameters:"
            echo -e "  \033[1mHOSTNAME\033[22m (required)"
            echo "      Target hostname."
            echo -e "  \033[1mPORT\033[22m (required, integer: 0-65535)"
            echo "      Target TCP port."
            echo -e "  \033[1mCONNECT_TIMEOUT_IN_SECONDS\033[22m (default: '5', integer: ?-?)"
            echo "      Number of seconds to try to connect to the given port. Default is 5 seconds."
            echo
            echo "Options:"
            echo -e "\033[1m-v, --verbose\033[22m"
            echo "        Prints additional information during command execution."
            echo "    -----------------------------"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            echo "Examples:"
            echo -e "$ \033[1m$__fn localhost 12345 1\033[22m"
            echo
            echo -e "$ \033[1m$__fn -v localhost 12345 1\033[22m"
            echo "localhost:12345 is not reachable."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn localhost 12345 1\033[22m"
            __stdout="$($__fn localhost 12345 1)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 1 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [1]."; return 64; fi
            if [[ -n "$__stdout" ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required string []."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn -v localhost 12345 1\033[22m"
            __stdout="$($__fn -v localhost 12345 1)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 1 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [1]."; return 64; fi
            __regex="localhost:12345 is not reachable."
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [localhost:12345 is not reachable.]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn localhost 70000\033[22m"
            __stdout="$($__fn localhost 70000)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 64 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [64]."; return 64; fi
            __regex="Error: Value '70000' for parameter PORT is too high. Must be <= 65535."
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [Error: Value '70000' for parameter PORT is too high. Must be <= 65535.]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --verbose|-v)
            _verbose=1
         ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      if [[ ! $_HOSTNAME ]]; then
         _HOSTNAME=$__param
         continue
      fi
      if [[ ! $_PORT ]]; then
         _PORT=$__param
         continue
      fi
      if [[ ! $_CONNECT_TIMEOUT_IN_SECONDS ]]; then
         _CONNECT_TIMEOUT_IN_SECONDS=$__param
         continue
      fi
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ ! $_CONNECT_TIMEOUT_IN_SECONDS ]]; then _CONNECT_TIMEOUT_IN_SECONDS="5"; fi

   if [[ $_HOSTNAME ]]; then
      true
   else
      echo "$__fn: Error: Parameter HOSTNAME must be specified."; return 64
   fi
   if [[ $_PORT ]]; then
      if [[ ! "$_PORT" =~ ^-?[0-9]*$ ]]; then echo "$__fn: Error: Value '$_PORT' for parameter PORT is not a numeric value."; return 64; fi
      if [[ $_PORT -lt 0 ]]; then echo "$__fn: Error: Value '$_PORT' for parameter PORT is too low. Must be >= 0."; return 64; fi
      if [[ $_PORT -gt 65535 ]]; then echo "$__fn: Error: Value '$_PORT' for parameter PORT is too high. Must be <= 65535."; return 64; fi
   else
      echo "$__fn: Error: Parameter PORT must be specified."; return 64
   fi
   if [[ $_CONNECT_TIMEOUT_IN_SECONDS ]]; then
      if [[ ! "$_CONNECT_TIMEOUT_IN_SECONDS" =~ ^-?[0-9]*$ ]]; then echo "$__fn: Error: Value '$_CONNECT_TIMEOUT_IN_SECONDS' for parameter CONNECT_TIMEOUT_IN_SECONDS is not a numeric value."; return 64; fi
   fi

####### is-port-open ####### START
[[ $_tracecmd ]] && set -x || true
if hash nc &>/dev/null; then
   if nc -vz -w $_CONNECT_TIMEOUT_IN_SECONDS $_HOSTNAME $_PORT; then
      portStatus=open
   else
      portStatus=
   fi
else
   local portStatus=$(perl << EOF
      use IO::Socket;
      my \$socket=IO::Socket::INET->new(
         PeerAddr => "$_HOSTNAME",
         PeerPort => $_PORT,
         Timeout => $_CONNECT_TIMEOUT_IN_SECONDS
      );

      if (defined \$socket) {
         sleep 1;
         (defined \$socket->connected ? print("open") : q{});
      }
EOF
   )
fi

if [[ $portStatus == "open" ]]; then
   [[ $_verbose ]] && echo "$_HOSTNAME:$_PORT is open." || true
   return 0
else
   [[ $_verbose ]] && echo "$_HOSTNAME:$_PORT is not reachable." || true
   return 1
fi
[[ $_tracecmd ]] && set +x || true
####### is-port-open ####### END
}
function __complete-is-port-open() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help --tracecmd --verbose -v "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}is-port-open -- ${BASH_FUNK_PREFIX:--}is-port-open

function -my-ips() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]...\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-my-ips() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _tracecmd
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]..."
            echo
            echo "Prints the configured IP v4 addresses of this host excluding 127.0.0.1."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

####### my-ips ####### START
[[ $_tracecmd ]] && set -x || true
if [[ $OSTYPE == cygwin || $OSTYPE == msys ]]; then
   ipconfig /all | grep "IPv4 Address" | grep -Eo '([0-9]*\.){3}[0-9]*' | grep -v '127.0.0.1'
else
   if [ -f /proc/net/fib_trie ]; then
      awk '/32 host/ { if(uniq[ip]++ && ip != "127.0.0.1") print ip } {ip=$2}' /proc/net/fib_trie
   elif hash ip &>/dev/null; then
      ip -4 -o addr show scope global | awk '{split($4, cidr, "/"); print cidr[1]}'
   elif hash ifconfig &>/dev/null; then
      ifconfig | grep -Eo 'inet (addr:)?([0-9]*\.){3}[0-9]*' | grep -Eo '([0-9]*\.){3}[0-9]*' | grep -v '127.0.0.1'
   else
      echo "Error: None of the required commands found: ip, ifconfig"
      return 1
   fi
fi
[[ $_tracecmd ]] && set +x || true
####### my-ips ####### END
}
function __complete-my-ips() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}my-ips -- ${BASH_FUNK_PREFIX:--}my-ips

function -my-public-hostname() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]...\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-my-public-hostname() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _method _help _selftest _tracecmd
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]..."
            echo
            echo "Prints the public hostname of this host."
            echo
            echo "Options:"
            echo -e "\033[1m-m, --method TYPE\033[22m (one of: [finger,ftp,https,nslookup,telnet])"
            echo "        Method to determine the public hostname. Default is 'https'."
            echo "    -----------------------------"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --method|-m)
            _method="@@##@@"
            __optionWithValue=method
         ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               method)
                  _method=$__arg
                  __optionWithValue=
                 ;;
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ $_method ]]; then
      if [[ $_method == "@@##@@" ]]; then echo "$__fn: Error: Value TYPE for option --method must be specified."; return 64; fi
      if [[ $_method != 'finger' && $_method != 'ftp' && $_method != 'https' && $_method != 'nslookup' && $_method != 'telnet' ]]; then echo "$__fn: Error: Value '$_method' for option --method is not one of the allowed values [finger,ftp,https,nslookup,telnet]."; return 64; fi
   fi

####### my-public-hostname ####### START
[[ $_tracecmd ]] && set -x || true
case ${_method:-https} in
   finger)
      if ! hash finger &>/dev/null; then
         echo "Required command 'ftp' is not available."
         return 1
      fi
      finger @4.ifcfg.me 2>/dev/null | sed -nE 's/Your Host is (.*)/\1/p'
      return ${PIPESTATUS[0]}
     ;;
   ftp)
      if ! hash ftp &>/dev/null; then
         echo "Required command 'ftp' is not available."
          return 1
      fi
      echo close | ftp 4.ifcfg.me 2>/dev/null | sed -nE 's/.*[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+ \((.*)\)/\1/p'
      return ${PIPESTATUS[0]}
     ;;
   https)
      hash wget &>/dev/null && local get="wget -qO- --user-agent=curl" || local get="curl -s"
      $get https://4.ifcfg.me/h
     ;;
   nslookup)
      if ! hash nslookup &>/dev/null; then
         echo "Required command 'nslookup' is not available."
         return 1
      fi
      nslookup . 4.ifcfg.me 2>/dev/null | sed -nE 's/Name:\t(.*)/\1//p'
      return ${PIPESTATUS[0]}
     ;;
   telnet)
      if ! hash telnet &>/dev/null; then
         echo "Required command 'telnet' is not available."
         return 1
      fi
      telnet 4.ifcfg.me 2>/dev/null | sed -nE 's/Your Host is (.*)/\1/p'
      return ${PIPESTATUS[0]}
     ;;
esac
[[ $_tracecmd ]] && set +x || true
####### my-public-hostname ####### END
}
function __complete-my-public-hostname() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --method -m --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      local prev="${COMP_WORDS[COMP_CWORD-1]}"
      case $prev in
         --method|-m)
            COMPREPLY=($(compgen -o default -W "finger
ftp
https
nslookup
telnet" -- $curr))
              ;;
         *)
            COMPREPLY=($(compgen -o default -- $curr))
           ;;
      esac
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}my-public-hostname -- ${BASH_FUNK_PREFIX:--}my-public-hostname

function -my-public-ip() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]...\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-my-public-ip() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _method _help _selftest _tracecmd
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]..."
            echo
            echo "Prints the public IP v4 address of this host."
            echo
            echo "Options:"
            echo -e "\033[1m-m, --method TYPE\033[22m (one of: [dns,http,https,nslookup,telnet])"
            echo "        Method to determine the public IP v4 address. Default is 'http'."
            echo "    -----------------------------"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --method|-m)
            _method="@@##@@"
            __optionWithValue=method
         ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               method)
                  _method=$__arg
                  __optionWithValue=
                 ;;
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ $_method ]]; then
      if [[ $_method == "@@##@@" ]]; then echo "$__fn: Error: Value TYPE for option --method must be specified."; return 64; fi
      if [[ $_method != 'dns' && $_method != 'http' && $_method != 'https' && $_method != 'nslookup' && $_method != 'telnet' ]]; then echo "$__fn: Error: Value '$_method' for option --method is not one of the allowed values [dns,http,https,nslookup,telnet]."; return 64; fi
   fi

####### my-public-ip ####### START
[[ $_tracecmd ]] && set -x || true
case ${_method:-http} in
   dns)
      if hash dig &>/dev/null; then
         dig @resolver1.opendns.com -4 myip.opendns.com +short
      elif ! hash host &>/dev/null; then
         echo "Required command 'dig' or 'host' is not available."
         return 1
      else
         host myip.opendns.com resolver1.opendns.com | grep --color=never -oP '(?<=myip.opendns.com has address )[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+'
      fi
     ;;
   http)
      hash wget &>/dev/null && local get="wget -qO- --user-agent=curl" || local get="curl -s"
      # alternatives: icanhazip.com, ifconfig.co, ifconfig.me, ipecho.net
      $get http://whatismyip.akamai.com/
     ;;
   https)
      hash wget &>/dev/null && local get="wget -qO- --user-agent=curl" || local get="curl -s"
      # alternatives: icanhazip.com, ifconfig.co, ifconfig.me
      $get https://ipecho.net/plain
     ;;
   nslookup)
      if ! hash nslookup &>/dev/null; then
         echo "Required command 'nslookup' is not available."
         return 1
      fi
      nslookup myip.opendns.com resolver1.opendns.com | grep -oP '(?<=Address: )[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+'
      return ${PIPESTATUS[0]}
     ;;
   telnet)
      if ! hash telnet &>/dev/null; then
         echo "Required command 'telnet' is not available."
         return 1
      fi
      telnet telnetmyip.com 2>/dev/null | sed -nE 's/.*ip\": \"([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+).+/\1/p'
      return ${PIPESTATUS[0]}
     ;;
esac
[[ $_tracecmd ]] && set +x || true
####### my-public-ip ####### END
}
function __complete-my-public-ip() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --method -m --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      local prev="${COMP_WORDS[COMP_CWORD-1]}"
      case $prev in
         --method|-m)
            COMPREPLY=($(compgen -o default -W "dns
http
https
nslookup
telnet" -- $curr))
              ;;
         *)
            COMPREPLY=($(compgen -o default -- $curr))
           ;;
      esac
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}my-public-ip -- ${BASH_FUNK_PREFIX:--}my-public-ip

function -run-echo-server() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... [BIND_ADDRESS] PORT\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-run-echo-server() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _stop_when _disconnect_when _help _selftest _tracecmd _BIND_ADDRESS _PORT
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... [BIND_ADDRESS] PORT"
            echo
            echo "Runs a simple single-connection TCP echo server."
            echo
            echo "Requirements:"
            echo "  + Command 'python' must be available."
            echo
            echo "Parameters:"
            echo -e "  \033[1mBIND_ADDRESS\033[22m (default: '0.0.0.0')"
            echo "      The local bind address. E.g. 127.0.0.1."
            echo -e "  \033[1mPORT\033[22m (required, integer: 0-65535)"
            echo "      Number of the TCP port to be used."
            echo
            echo "Options:"
            echo -e "\033[1m    --disconnect_when string\033[22m"
            echo "        String that can be send to the server to disconnect the current connection."
            echo -e "\033[1m    --stop_when string\033[22m"
            echo "        String that can be send to the server to shut it down."
            echo "    -----------------------------"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --stop_when)
            _stop_when="@@##@@"
            __optionWithValue=stop_when
         ;;

         --disconnect_when)
            _disconnect_when="@@##@@"
            __optionWithValue=disconnect_when
         ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               stop_when)
                  _stop_when=$__arg
                  __optionWithValue=
                 ;;
               disconnect_when)
                  _disconnect_when=$__arg
                  __optionWithValue=
                 ;;
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      if [[ ! $_BIND_ADDRESS && ${#__params[@]} > 1 ]]; then
         _BIND_ADDRESS=$__param
         continue
      fi
      if [[ ! $_PORT ]]; then
         _PORT=$__param
         continue
      fi
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ ! $_BIND_ADDRESS ]]; then _BIND_ADDRESS="0.0.0.0"; fi
   if [[ $_stop_when ]]; then
      if [[ $_stop_when == "@@##@@" ]]; then echo "$__fn: Error: Value string for option --stop_when must be specified."; return 64; fi
   fi
   if [[ $_disconnect_when ]]; then
      if [[ $_disconnect_when == "@@##@@" ]]; then echo "$__fn: Error: Value string for option --disconnect_when must be specified."; return 64; fi
   fi

   if [[ $_PORT ]]; then
      if [[ ! "$_PORT" =~ ^-?[0-9]*$ ]]; then echo "$__fn: Error: Value '$_PORT' for parameter PORT is not a numeric value."; return 64; fi
      if [[ $_PORT -lt 0 ]]; then echo "$__fn: Error: Value '$_PORT' for parameter PORT is too low. Must be >= 0."; return 64; fi
      if [[ $_PORT -gt 65535 ]]; then echo "$__fn: Error: Value '$_PORT' for parameter PORT is too high. Must be <= 65535."; return 64; fi
   else
      echo "$__fn: Error: Parameter PORT must be specified."; return 64
   fi

   if ! hash "python" &>/dev/null; then echo "$__fn: Error: Required command 'python' not found on this system."; return 64; fi

####### run-echo-server ####### START
[[ $_tracecmd ]] && set -x || true
if [[ ! $_stop_when ]]; then
   local _stop_when=stop
fi

if [[ ! $_disconnect_when ]]; then
   local _disconnect_when=quit
fi

python -c "
import socket, sys

def run():
   srv = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
   srv.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
   srv.bind(('$_BIND_ADDRESS', $_PORT))
   srv.listen(0)

   print('Running TCP echo server on $_BIND_ADDRESS:$_PORT...')

   while 1:
      conn, src_addr = srv.accept()
      print('[CONNECT] %s' % src_addr)
      while 1:
         data, src_addr = conn.recvfrom(256)
         if not data:
            continue
         if data == '$_stop_when\r\n':
            print('[SHUTDOWN] %s' % src_addr)
            sys.exit(0)
         if data == '$_disconnect_when\r\n':
            print('[DISCONNECT] %s' % src_addr)
            conn.shutdown(1)
            conn.close()
            break
         conn.sendall(data)
         sys.stdout.write(data)
         sys.stdout.flush()
try:
   run()
except KeyboardInterrupt:
   pass
"
[[ $_tracecmd ]] && set +x || true
####### run-echo-server ####### END
}
function __complete-run-echo-server() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --stop_when --disconnect_when --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}run-echo-server -- ${BASH_FUNK_PREFIX:--}run-echo-server

function -set-proxy() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... PROXY_URL [NO_PROXY]\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-set-proxy() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _tracecmd _verbose _PROXY_URL _NO_PROXY
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... PROXY_URL [NO_PROXY]"
            echo
            echo "Sets the proxy environment variables."
            echo
            echo "Parameters:"
            echo -e "  \033[1mPROXY_URL\033[22m (required)"
            echo "      The proxy URL to set."
            echo -e "  \033[1mNO_PROXY\033[22m"
            echo "      Proxy exclusions."
            echo
            echo "Options:"
            echo -e "\033[1m-v, --verbose\033[22m"
            echo "        Prints additional information during command execution."
            echo "    -----------------------------"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --verbose|-v)
            _verbose=1
         ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      if [[ ! $_PROXY_URL ]]; then
         _PROXY_URL=$__param
         continue
      fi
      if [[ ! $_NO_PROXY ]]; then
         _NO_PROXY=$__param
         continue
      fi
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ $_PROXY_URL ]]; then
      true
   else
      echo "$__fn: Error: Parameter PROXY_URL must be specified."; return 64
   fi

####### set-proxy ####### START
[[ $_tracecmd ]] && set -x || true
for varname in all_proxy ALL_PROXY ftp_proxy FTP_PROXY http_proxy HTTP_PROXY https_proxy HTTPS_PROXY; do
   [[ $_verbose ]] && echo "Setting $varname=$_PROXY_URL"
   export $varname=$_PROXY_URL
done

# exclude local IPs from proxy
if hash ifconfig &>/dev/null; then
   local my_ips=$(ifconfig | grep -Eo 'inet (addr:)?([0-9]*\.){3}[0-9]*' | grep -Eo '([0-9]*\.){3}[0-9]*')
else
   local my_ips=::1,127.0.0.1
fi
no_proxy=localhost,${my_ips//$'\n'/,}

# exclude metadata IP if AWS EC2 server
if [[ -f /sys/hypervisor/uuid && $(head -c 3 /sys/hypervisor/uuid) == "ec2" ]]; then
   no_proxy="$no_proxy,169.254.169.254"
fi

export no_proxy="$no_proxy,$_NO_PROXY"
[[ $_verbose ]] && echo "Setting no_proxy=$no_proxy"
[[ $_verbose ]] && echo "Setting NO_PROXY="
export NO_PROXY=$no_proxy
[[ $_tracecmd ]] && set +x || true
####### set-proxy ####### END
}
function __complete-set-proxy() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help --tracecmd --verbose -v "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}set-proxy -- ${BASH_FUNK_PREFIX:--}set-proxy

function -test-all-network() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]...\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-test-all-network() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _tracecmd
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]..."
            echo
            echo "Performs a selftest of all functions of this module by executing each function with option '--selftest'."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

####### test-all-network ####### START
[[ $_tracecmd ]] && set -x || true
${BASH_FUNK_PREFIX:--}block-port --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}flush-dns --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}is-port-open --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}my-ips --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}my-public-hostname --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}my-public-ip --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}run-echo-server --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}set-proxy --selftest && echo || return 1
[[ $_tracecmd ]] && set +x || true
####### test-all-network ####### END
}
function __complete-test-all-network() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}test-all-network -- ${BASH_FUNK_PREFIX:--}test-all-network


function -help-network() {
   local p="\033[1m${BASH_FUNK_PREFIX:--}"
   echo -e "${p}block-port [BIND_ADDRESS] PORT\033[0m  -  Binds to the given port and thus block other programs from binding to it."
   echo -e "${p}flush-dns\033[0m  -  Flushes the local DNS cache."
   echo -e "${p}is-port-open HOSTNAME PORT [CONNECT_TIMEOUT_IN_SECONDS]\033[0m  -  Checks if a TCP connection can be established to the given port."
   echo -e "${p}my-ips\033[0m  -  Prints the configured IP v4 addresses of this host excluding 127.0.0.1."
   echo -e "${p}my-public-hostname\033[0m  -  Prints the public hostname of this host."
   echo -e "${p}my-public-ip\033[0m  -  Prints the public IP v4 address of this host."
   echo -e "${p}run-echo-server [BIND_ADDRESS] PORT\033[0m  -  Runs a simple single-connection TCP echo server."
   echo -e "${p}set-proxy PROXY_URL [NO_PROXY]\033[0m  -  Sets the proxy environment variables."
   echo -e "${p}test-all-network\033[0m  -  Performs a selftest of all functions of this module by executing each function with option '--selftest'."
}
__BASH_FUNK_FUNCS+=( block-port flush-dns is-port-open my-ips my-public-hostname my-public-ip run-echo-server set-proxy test-all-network )
