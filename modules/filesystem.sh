#!/usr/bin/env bash
#
# SPDX-FileCopyrightText: Â© Vegard IT GmbH (https://vegardit.com)
# SPDX-License-Identifier: Apache-2.0
#
# @author Sebastian Thomschke, Vegard IT GmbH
# @author Patrick Spielmann, Vegard IT GmbH
#
# THIS FILE IS GENERATED BY BASH-FUNK GENERATOR
#
# documentation: https://github.com/vegardit/bash-funk/tree/main/docs/filesystem.md
#

function -abspath() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... [PATH]\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-abspath() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _tracecmd _PATH
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... [PATH]"
            echo
            echo "Prints the normalized path of the given path WITHOUT resolving symbolic links. The path is not required to exist."
            echo
            echo "Parameters:"
            echo -e "  \033[1mPATH\033[22m (default: '.')"
            echo "      The path to normalize."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      if [[ ! $_PATH && ${#__params[@]} > 0 ]]; then
         _PATH=$__param
         continue
      fi
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ ! $_PATH ]]; then _PATH="."; fi

####### abspath ####### START
[[ $_tracecmd ]] && set -x || true

# use realpath if available
if hash realpath &>/dev/null; then
   realpath -m $_PATH

# use python as last resort
else
   python -c "import os
print(os.path.abspath('$_PATH'))"
fi
[[ $_tracecmd ]] && set +x || true
####### abspath ####### END
}
function __complete-abspath() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}abspath -- ${BASH_FUNK_PREFIX:--}abspath

function -cd-down() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... [START_AT] DIR_NAME\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-cd-down() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _tracecmd _START_AT _DIR_NAME
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... [START_AT] DIR_NAME"
            echo
            echo "Jumps down in the tree of the current directory to the first sub directory found with the given name."
            echo
            echo "Parameters:"
            echo -e "  \033[1mSTART_AT\033[22m (default: '.')"
            echo "      The start directory."
            echo -e "  \033[1mDIR_NAME\033[22m (required)"
            echo "      The name of the subdirectory to locate and cd into."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      if [[ ! $_START_AT && ${#__params[@]} > 1 ]]; then
         _START_AT=$__param
         continue
      fi
      if [[ ! $_DIR_NAME ]]; then
         _DIR_NAME=$__param
         continue
      fi
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ ! $_START_AT ]]; then _START_AT="."; fi

   if [[ $_DIR_NAME ]]; then
      true
   else
      echo "$__fn: Error: Parameter DIR_NAME must be specified."; return 64
   fi

####### cd-down ####### START
[[ $_tracecmd ]] && set -x || true
local path=$(find $_START_AT -name "$_DIR_NAME" -type d -print -quit 2>/dev/null || true);
if [[ $path ]]; then
   echo "$path"
   cd $path
else
   echo "$__fn: $_DIR_NAME: No such directory"
   return 1
fi
[[ $_tracecmd ]] && set +x || true
####### cd-down ####### END
}
function __complete-cd-down() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}cd-down -- ${BASH_FUNK_PREFIX:--}cd-down

function -cd-hist() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... [STEPS_OR_DIRNAME]\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-cd-hist() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _tracecmd _STEPS_OR_DIRNAME
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... [STEPS_OR_DIRNAME]"
            echo
            echo "Navigates back in the directory history which can be managed via pushd/popd/dirs and is automatically populated if the Bash Funk bash-prompt is installed."
            echo
            echo "Parameters:"
            echo -e "  \033[1mSTEPS_OR_DIRNAME\033[22m"
            echo "      The name of the subdirectory to locate and cd into. If not specified a list of the last 20 entries is displayed."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      if [[ ! $_STEPS_OR_DIRNAME && ${#__params[@]} > 0 ]]; then
         _STEPS_OR_DIRNAME=$__param
         continue
      fi
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

####### cd-hist ####### START
[[ $_tracecmd ]] && set -x || true
if [[ ! $_STEPS_OR_DIRNAME ]]; then
   echo "Directory history:"
   for (( __idx=2; __idx<${#DIRSTACK[*]}; __idx++ )); do
      echo "$(( __idx - 1 )) cd ${DIRSTACK[$__idx]}"
      [[ $__idx -eq 22 ]] && break || true
   done
   return 0
fi

if [[ $_STEPS_OR_DIRNAME == "-" ]]; then
   cd - && return 0 || return 1
fi

if [[ $_STEPS_OR_DIRNAME =~ ^[0-9]+$ ]]; then
   local path="${DIRSTACK[@]:$(( _STEPS_OR_DIRNAME + 1 )):1}"
   echo "$path"
   cd $path
else
   local path
   for path in "${DIRSTACK[@]}"; do
      case "${path}" in
         *"/"$_STEPS_OR_DIRNAME)
            echo "$path"
            cd "$path"
            return 0;
          ;;
      esac
   done
   echo "$__fn: $_STEPS_OR_DIRNAME: No such directory in history"
   return 1
fi
[[ $_tracecmd ]] && set +x || true
####### cd-hist ####### END
}
function __complete-cd-hist() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}cd-hist -- ${BASH_FUNK_PREFIX:--}cd-hist

function -cd-up() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... [LEVEL_OR_PATTERN]\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-cd-up() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _tracecmd _LEVEL_OR_PATTERN
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... [LEVEL_OR_PATTERN]"
            echo
            echo "Navigates up in the current directory tree to the first parent directory found with the given namen or the given number of levels. Bash completion will auto-complete the names of the parent directories."
            echo
            echo "Parameters:"
            echo -e "  \033[1mLEVEL_OR_PATTERN\033[22m (default: '..')"
            echo "      The number of directories to navigate up in the directory tree or the glob pattern to find a matching directory."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      if [[ ! $_LEVEL_OR_PATTERN && ${#__params[@]} > 0 ]]; then
         _LEVEL_OR_PATTERN=$__param
         continue
      fi
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ ! $_LEVEL_OR_PATTERN ]]; then _LEVEL_OR_PATTERN=".."; fi

####### cd-up ####### START
[[ $_tracecmd ]] && set -x || true
if [[ $_LEVEL_OR_PATTERN == ".." ]]; then
   cd ..
   return 0
fi

# check if value is numeric
if [[ $_LEVEL_OR_PATTERN =~ ^[0-9]+$ ]]; then
   local path
   for (( i = 0; i < _LEVEL_OR_PATTERN; i++ )); do
      path="../$path"
   done
   echo "$path"
   cd "$path"

else
   local elem path=()

   # read current path elements into array 'path'
   IFS=/ read -r -a path <<< "$PWD"

   # iterate reverse through the array and check for matching directory
   for (( idx=${#path[@]}-2; idx>=0; idx-- )); do
      case "${path[idx]}" in
         $_LEVEL_OR_PATTERN)
            # join the path
            IFS="/" eval 'path="${path[*]:0:$((idx+1))}"'
            echo "$path"
            cd "$path"
            return 0;
           ;;
      esac
   done
   echo "$__fn: $_LEVEL_OR_PATTERN: No such directory"
   return 1
fi
[[ $_tracecmd ]] && set +x || true
####### cd-up ####### END
}
function __complete-cd-up() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      local path="$PWD"; COMPREPLY=($(IFS=$'\n' compgen -o default -W "$( echo -e "${path////\n}" | sed 's/^/\x27/; s/$/\x27/' )" -- "$curr"))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}cd-up -- ${BASH_FUNK_PREFIX:--}cd-up

function -count-words() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... WORD1 [WORD]...\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-count-words() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _sort _file _help _selftest _tracecmd _WORD=()
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... WORD1 [WORD]..."
            echo
            echo "Counts the number of occurences of the word(s) in the text read from stdin."
            echo
            echo "Parameters:"
            echo -e "  \033[1mWORD\033[22m (1 or more required)"
            echo "      The word to count."
            echo
            echo "Options:"
            echo -e "\033[1m-f, --file PATH\033[22m (file)"
            echo "        Count the words in the given file instead of reading from stdin."
            echo -e "\033[1m-s, --sort MODE\033[22m (one of: [count,word])"
            echo "        Specifies how to sort the output."
            echo "    -----------------------------"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --sort|-s)
            _sort="@@##@@"
            __optionWithValue=sort
         ;;

         --file|-f)
            _file="@@##@@"
            __optionWithValue=file
         ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               sort)
                  _sort=$__arg
                  __optionWithValue=
                 ;;
               file)
                  _file=$__arg
                  __optionWithValue=
                 ;;
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      _WORD+=("$__param")
      continue
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ $_sort ]]; then
      if [[ $_sort == "@@##@@" ]]; then echo "$__fn: Error: Value MODE for option --sort must be specified."; return 64; fi
      if [[ $_sort != 'count' && $_sort != 'word' ]]; then echo "$__fn: Error: Value '$_sort' for option --sort is not one of the allowed values [count,word]."; return 64; fi
   fi
   if [[ $_file ]]; then
      if [[ $_file == "@@##@@" ]]; then echo "$__fn: Error: Value PATH for option --file must be specified."; return 64; fi
      if [[ ! -e "$_file" ]]; then echo "$__fn: Error: File '$_file' for option --file does not exist."; return 64; fi
      if [[ -e "$_file" && ! -f "$_file" ]]; then echo "$__fn: Error: Path '$_file' for option --file is not a file."; return 64; fi
      if [[ ! -r "$_file" ]]; then echo "$__fn: Error: File '$_file' for option --file is not readable by user '$USER'."; return 64; fi
   fi

   if [[ ${#_WORD[@]} -lt 1 ]]; then echo "$__fn: Error: For parameter WORD at least 1 value must be specified. Found: ${#_WORD[@]}."; return 64; fi

####### count-words ####### START
[[ $_tracecmd ]] && set -x || true
local sedCmds grepCmds
for word in "${_WORD[@]}"; do
   sedCmds="s/$word/\n$word\n/g; $sedCmds"
   grepCmds="$grepCmds -e $word"
done

if [[ $_file ]]; then
   if [[ $_sort == "count" ]]; then
      sed "$sedCmds" "$_file" | grep $grepCmds | sort | uniq -c | sort -r
   else
      sed "$sedCmds" "$_file" | grep $grepCmds | sort | uniq -c
   fi
else
   # check if stdin is opend on terminal (and thus not on a pipe)
   if [[ -t 0 ]]; then
      return 0
   fi

   if [[ $_sort == "count" ]]; then
      cat /dev/fd/0 | sed "$sedCmds" | grep $grepCmds | sort | uniq -c | sort -r
   else
      cat /dev/fd/0 | sed "$sedCmds" | grep $grepCmds | sort | uniq -c
   fi
fi
[[ $_tracecmd ]] && set +x || true
####### count-words ####### END
}
function __complete-count-words() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --sort -s --file -f --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      local prev="${COMP_WORDS[COMP_CWORD-1]}"
      case $prev in
         --sort|-s)
            COMPREPLY=($(compgen -o default -W "count
word" -- $curr))
              ;;
         *)
            COMPREPLY=($(compgen -o default -- $curr))
           ;;
      esac
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}count-words -- ${BASH_FUNK_PREFIX:--}count-words

function -du() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... [PATH]...\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-du() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _tracecmd _PATH=()
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... [PATH]..."
            echo
            echo "Prints disk usage information."
            echo
            echo "Parameters:"
            echo -e "  \033[1mPATH\033[22m"
            echo "      The path to check."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      _PATH+=("$__param")
      continue
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

####### du ####### START
[[ $_tracecmd ]] && set -x || true
[[ ! $_PATH ]] && _PATH=(.) || true

du -s -h "${_PATH[@]}"
[[ $_tracecmd ]] && set +x || true
####### du ####### END
}
function __complete-du() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}du -- ${BASH_FUNK_PREFIX:--}du

function -extract() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... ARCHIVE [TO_DIR]\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-extract() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _tracecmd _ARCHIVE _TO_DIR
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... ARCHIVE [TO_DIR]"
            echo
            echo "Extracts the given archive using the compatible extractor."
            echo
            echo "Parameters:"
            echo -e "  \033[1mARCHIVE\033[22m (required, file)"
            echo "      The archive to extract."
            echo -e "  \033[1mTO_DIR\033[22m"
            echo "      The target folder."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      if [[ ! $_ARCHIVE ]]; then
         _ARCHIVE=$__param
         continue
      fi
      if [[ ! $_TO_DIR ]]; then
         _TO_DIR=$__param
         continue
      fi
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ $_ARCHIVE ]]; then
      if [[ ! -e "$_ARCHIVE" ]]; then echo "$__fn: Error: File '$_ARCHIVE' for parameter ARCHIVE does not exist."; return 64; fi
      if [[ -e "$_ARCHIVE" && ! -f "$_ARCHIVE" ]]; then echo "$__fn: Error: Path '$_ARCHIVE' for parameter ARCHIVE is not a file."; return 64; fi
      if [[ ! -r "$_ARCHIVE" ]]; then echo "$__fn: Error: File '$_ARCHIVE' for parameter ARCHIVE is not readable by user '$USER'."; return 64; fi
   else
      echo "$__fn: Error: Parameter ARCHIVE must be specified."; return 64
   fi

####### extract ####### START
[[ $_tracecmd ]] && set -x || true
if [[ $_TO_DIR ]]; then
   local origPWD="$PWD"
   mkdir "$_TO_DIR"
   cd "$_TO_DIR"
fi

if [[ ! -w "$PWD" ]]; then
   echo "$__fn: Error: Path [$PWD] is not writeable."
   return 1
fi

local tmpDir=$(mktemp -d -p "$PWD")

case "$_FILE" in
   *.bz2)            bunzip2    "$_ARCHIVE" ;;
   *.gz)             gunzip     "$_ARCHIVE" ;;
   *.rar)            unrar x    "$_ARCHIVE" ;;
   *.tar)            tar xvf    "$_ARCHIVE" ;;
   *.tbz2|*.tar.bz2) tar xvjf   "$_ARCHIVE" ;;
   *.tgz|*.tar.gz)   tar xvzf   "$_ARCHIVE" ;;
   *.zip)            unzip      "$_ARCHIVE" ;;
   *.Z)              uncompress "$_ARCHIVE" ;;
   *.7z)             7z x       "$_ARCHIVE" ;;
   *) echo "$__fn: Error: Unsupported archive format '$_ARCHIVE'"; return 1 ;;
esac

if [[ $_TO_DIR ]]; then
   cd "$origPWD"
fi
[[ $_tracecmd ]] && set +x || true
####### extract ####### END
}
function __complete-extract() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}extract -- ${BASH_FUNK_PREFIX:--}extract

function -find-up() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... FILENAME\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-find-up() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _type _help _selftest _tracecmd _FILENAME
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... FILENAME"
            echo
            echo "Traverses the directory upward to find the given file."
            echo
            echo "Parameters:"
            echo -e "  \033[1mFILENAME\033[22m (required)"
            echo "      The file or directory to find."
            echo
            echo "Options:"
            echo -e "\033[1m-t, --type TYPE\033[22m (one of: [d,dir,f,file])"
            echo "        File type."
            echo "    -----------------------------"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --type|-t)
            _type="@@##@@"
            __optionWithValue=type
         ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               type)
                  _type=$__arg
                  __optionWithValue=
                 ;;
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      if [[ ! $_FILENAME ]]; then
         _FILENAME=$__param
         continue
      fi
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ $_type ]]; then
      if [[ $_type == "@@##@@" ]]; then echo "$__fn: Error: Value TYPE for option --type must be specified."; return 64; fi
      if [[ $_type != 'd' && $_type != 'dir' && $_type != 'f' && $_type != 'file' ]]; then echo "$__fn: Error: Value '$_type' for option --type is not one of the allowed values [d,dir,f,file]."; return 64; fi
   fi

   if [[ $_FILENAME ]]; then
      true
   else
      echo "$__fn: Error: Parameter FILENAME must be specified."; return 64
   fi

####### find-up ####### START
[[ $_tracecmd ]] && set -x || true
local path=$PWD
while [[ $path ]]; do
   case $_type in
      d|dir)  if [[ -d "$path/$_FILENAME" ]]; then echo "$path/$_FILENAME"; return; fi ;;
      f|file) if [[ -f "$path/$_FILENAME" ]]; then echo "$path/$_FILENAME"; return; fi ;;
      *)      if [[ -e "$path/$_FILENAME" ]]; then echo "$path/$_FILENAME"; return; fi ;;
   esac
   path=${path%/*}
done
echo "$__fn: '$_FILENAME': No such file or directory"
return 1
[[ $_tracecmd ]] && set +x || true
####### find-up ####### END
}
function __complete-find-up() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --type -t --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      local prev="${COMP_WORDS[COMP_CWORD-1]}"
      case $prev in
         --type|-t)
            COMPREPLY=($(compgen -o default -W "d
dir
f
file" -- $curr))
              ;;
         *)
            COMPREPLY=($(compgen -o default -- $curr))
           ;;
      esac
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}find-up -- ${BASH_FUNK_PREFIX:--}find-up

function -findfiles() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... [START_PATH] SEARCH_STRING\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-findfiles() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _lines _unpack _maxdepth _mindepth _name _help _selftest _tracecmd _verbose _START_PATH _SEARCH_STRING
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... [START_PATH] SEARCH_STRING"
            echo
            echo "Recursively finds all files containing the given string and displays their path."
            echo
            echo "Parameters:"
            echo -e "  \033[1mSTART_PATH\033[22m (default: '.')"
            echo "      The path where to search."
            echo -e "  \033[1mSEARCH_STRING\033[22m (required)"
            echo "      The string to search."
            echo
            echo "Options:"
            echo -e "\033[1m-l, --lines\033[22m"
            echo "        Show matching lines of the files that contain the given string."
            echo -e "\033[1m    --maxdepth levels\033[22m (integer: ?-?)"
            echo "        The maximum number of levels to descend into the directory tree below the starting-point."
            echo -e "\033[1m    --mindepth levels\033[22m (integer: ?-?)"
            echo "        The level of directory tree below the starting-point where to start the search."
            echo -e "\033[1m    --name pattern\033[22m"
            echo "        Name pattern."
            echo -e "\033[1m-u, --unpack\033[22m"
            echo "        Unpack supported archives (.zip, .jar, .war, .ear)."
            echo -e "\033[1m-v, --verbose\033[22m"
            echo "        Prints additional information during command execution."
            echo "    -----------------------------"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --lines|-l)
            _lines=1
         ;;

         --unpack|-u)
            _unpack=1
         ;;

         --maxdepth)
            _maxdepth="@@##@@"
            __optionWithValue=maxdepth
         ;;

         --mindepth)
            _mindepth="@@##@@"
            __optionWithValue=mindepth
         ;;

         --name)
            _name="@@##@@"
            __optionWithValue=name
         ;;

         --verbose|-v)
            _verbose=1
         ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               maxdepth)
                  _maxdepth=$__arg
                  __optionWithValue=
                 ;;
               mindepth)
                  _mindepth=$__arg
                  __optionWithValue=
                 ;;
               name)
                  _name=$__arg
                  __optionWithValue=
                 ;;
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      if [[ ! $_START_PATH && ${#__params[@]} > 1 ]]; then
         _START_PATH=$__param
         continue
      fi
      if [[ ! $_SEARCH_STRING ]]; then
         _SEARCH_STRING=$__param
         continue
      fi
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ ! $_START_PATH ]]; then _START_PATH="."; fi
   if [[ $_maxdepth ]]; then
      if [[ $_maxdepth == "@@##@@" ]]; then echo "$__fn: Error: Value levels for option --maxdepth must be specified."; return 64; fi
      if [[ ! "$_maxdepth" =~ ^-?[0-9]*$ ]]; then echo "$__fn: Error: Value '$_maxdepth' for option --maxdepth is not a numeric value."; return 64; fi
   fi
   if [[ $_mindepth ]]; then
      if [[ $_mindepth == "@@##@@" ]]; then echo "$__fn: Error: Value levels for option --mindepth must be specified."; return 64; fi
      if [[ ! "$_mindepth" =~ ^-?[0-9]*$ ]]; then echo "$__fn: Error: Value '$_mindepth' for option --mindepth is not a numeric value."; return 64; fi
   fi
   if [[ $_name ]]; then
      if [[ $_name == "@@##@@" ]]; then echo "$__fn: Error: Value pattern for option --name must be specified."; return 64; fi
   fi

   if [[ $_SEARCH_STRING ]]; then
      true
   else
      echo "$__fn: Error: Parameter SEARCH_STRING must be specified."; return 64
   fi

####### findfiles ####### START
[[ $_tracecmd ]] && set -x || true
if [[ ! -e "$_START_PATH" ]]; then
   echo "$__fn: Error: Path [$_START_PATH] does not exist."
   return 1
fi

if [[ ! -r "$_START_PATH" ]]; then
   echo "$__fn: Error: Path [$_START_PATH] is not readable by user '$USER'."
   return 1
fi

if [[ $_lines ]]; then
   local grepCmd="grep -n"
else
   local grepCmd="grep -l"
fi

local findOpts="-type f"
if [[ $_name ]];     then findOpts="$findOpts -name $_name"; fi
if [[ $_maxdepth ]]; then findOpts="$findOpts -maxdepth $_maxdepth"; fi
if [[ $_mindepth ]]; then findOpts="$findOpts -mindepth $_mindepth"; fi

# turn off verbose if part of pipe or subshell
[[ ! $__interactive ]] && _verbose= || true

if [[ $_verbose ]]; then
   if hash tput &>/dev/null; then
      cols=$(tput cols)
   else
      cols=$(stty size| cut -d' ' -f 2)
   fi

   find "$_START_PATH" $findOpts 2>/dev/null | while read file; do
      local message="Scanning $file ..."

      echo -en "\033[s${message:0:$cols}"
      if [[ $_unpack && ( $file == *.zip || $file == *.jar || $file == *.ear || $file == *.war ) ]]; then
         if unzip -p "$file" | LC_ALL=C $grepCmd "$_SEARCH_STRING" "$file" 2>&1 >/dev/null; then
            echo -e "\033[u\033[K$file" || echo -e "$file"
         else
            echo -en "\033[u\033[K"
         fi
      else
         if LC_ALL=C $grepCmd "$_SEARCH_STRING" "$file" 2>&1 >/dev/null; then
            echo -e "\033[u\033[K$file" || echo -e "$file"
         else
            echo -en "\033[u\033[K"
         fi
      fi
   done

else

   if [[ $_unpack ]]; then
      find "$_START_PATH" $findOpts 2>/dev/null | while read file; do
         if [[ $file == *.zip || $file == *.jar || $file == *.ear || $file == *.war ]]; then
            unzip -p "$file" | LC_ALL=C $grepCmd "$_SEARCH_STRING" "$file" 2>/dev/null || true
         else
            LC_ALL=C $grepCmd "$_SEARCH_STRING" "$file" 2>/dev/null
         fi
      done
   else
      find "$_START_PATH" $findOpts -print0 | LC_ALL=C xargs -r -0 -P2 $grepCmd "$_SEARCH_STRING" 2>/dev/null
   fi
fi
[[ $_tracecmd ]] && set +x || true
####### findfiles ####### END
}
function __complete-findfiles() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --lines -l --unpack -u --maxdepth --mindepth --name --help --tracecmd --verbose -v "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}findfiles -- ${BASH_FUNK_PREFIX:--}findfiles

function -ll() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... [PATH]...\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-ll() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _tracecmd _PATH=()
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... [PATH]..."
            echo
            echo "Alternative version of 'ls -lt' that prints directories (and sym-links to directories) before files and hidden entries before non-hidden entries."
            echo
            echo "Parameters:"
            echo -e "  \033[1mPATH\033[22m"
            echo "      The path to list."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      _PATH+=("$__param")
      continue
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

####### ll ####### START
[[ $_tracecmd ]] && set -x || true
[[ ! $_PATH ]] && _PATH=(.) || true

local _ls="command ls -lAph \"${_PATH[@]}\""
[[ $OSTYPE == "darwin"* ]] && _ls="$_ls -G" || _ls="$_ls -I lost+found --color=always"
eval $_ls | awk '
   BEGIN { dotDirs = ""; dirs = ""; dotFiles = ""; files = "" }
   /^total/                                                                                       { total = $0 }                    # capture total line

   /^d[rwxXst+-]+.? .* ([0-9][0-9][0-9][0-9]|[0-9]+:[0-9]+) (\033\[[0-9;]+m)?[.].+/                 { dotDirs = dotDirs    "\n" $0 }; # capture hidden directories
   /^d[rwxXst+-]+.? .* ([0-9][0-9][0-9][0-9]|[0-9]+:[0-9]+) (\033\[[0-9;]+m[^.]|[^\033^.])/         { dirs    = dirs       "\n" $0 }; # capture normal directories
   /^l[rwxXst+-]+.? .* ([0-9][0-9][0-9][0-9]|[0-9]+:[0-9]+) (\033\[[0-9;]+m)?[.].+[\/]/             { dotDirs = dotDirs    "\n" $0 }; # capture hidden sym-links to directories
   /^l[rwxXst+-]+.? .* ([0-9][0-9][0-9][0-9]|[0-9]+:[0-9]+) (\033\[[0-9;]+m[^.]|[^\033^.]).*[\/]$/  { dirs    = dirs       "\n" $0 }; # capture normal sym-links to directories

   /^-[rwxXst+-]+.? .* ([0-9][0-9][0-9][0-9]|[0-9]+:[0-9]+) (\033\[[0-9;]+m)?[.].+/                 { dotFiles = dotFiles "\n" $0 };  # capture hidden files
   /^-[rwxXst+-]+.? .* ([0-9][0-9][0-9][0-9]|[0-9]+:[0-9]+) (\033\[[0-9;]+m[^.]|[^\033^.])/         { files    = files    "\n" $0 };  # capture normal files
   /^l[rwxXst+-]+.? .* ([0-9][0-9][0-9][0-9]|[0-9]+:[0-9]+) (\033\[[0-9;]+m)?[.].+[^\/]/            { dotFiles = dotFiles "\n" $0 };  # capture hidden sym-links to files
   /^l[rwxXst+-]+.? .* ([0-9][0-9][0-9][0-9]|[0-9]+:[0-9]+) (\033\[[0-9;]+m[^.]|[^\033^.]).*[^\/]$/ { files    = files    "\n" $0 };  # capture normal sym-links to files
   END { print total dotDirs dirs dotFiles files }'
[[ $_tracecmd ]] && set +x || true
####### ll ####### END
}
function __complete-ll() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}ll -- ${BASH_FUNK_PREFIX:--}ll

function -mkcd() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... PATH\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-mkcd() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _mode _parents _help _selftest _tracecmd _verbose _PATH
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... PATH"
            echo
            echo "Creates a directory and changes into it."
            echo
            echo "Parameters:"
            echo -e "  \033[1mPATH\033[22m (required)"
            echo "      The path to create."
            echo
            echo "Options:"
            echo -e "\033[1m-m, --mode MODE\033[22m (pattern: \"[0-7]{3}\")"
            echo "        The file mode for the new directory."
            echo -e "\033[1m-p, --parents\033[22m"
            echo "        Automatically create missing parent directories."
            echo -e "\033[1m-v, --verbose\033[22m"
            echo "        Prints additional information during command execution."
            echo "    -----------------------------"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --mode|-m)
            _mode="@@##@@"
            __optionWithValue=mode
         ;;

         --parents|-p)
            _parents=1
         ;;

         --verbose|-v)
            _verbose=1
         ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               mode)
                  _mode=$__arg
                  __optionWithValue=
                 ;;
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      if [[ ! $_PATH ]]; then
         _PATH=$__param
         continue
      fi
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ $_mode ]]; then
      if [[ $_mode == "@@##@@" ]]; then echo "$__fn: Error: Value MODE for option --mode must be specified."; return 64; fi
      if [[ ! "$_mode" =~ ^[0-7]{3}$ ]]; then echo "$__fn: Error: Value '$_mode' for option --mode does not match required pattern '[0-7]{3}'."; return 64; fi
   fi

   if [[ $_PATH ]]; then
      true
   else
      echo "$__fn: Error: Parameter PATH must be specified."; return 64
   fi

####### mkcd ####### START
[[ $_tracecmd ]] && set -x || true
local mkdirOpts

[[ $_mode    ]] && mkdirOpts="$mkdirOpts -m $_mode" || true
[[ $_parents ]] && mkdirOpts="$mkdirOpts -p" || true
[[ $_verbose ]] && mkdirOpts="$mkdirOpts -v" || true

mkdir "$_PATH" && cd "$_PATH"
[[ $_tracecmd ]] && set +x || true
####### mkcd ####### END
}
function __complete-mkcd() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --mode -m --parents -p --help --tracecmd --verbose -v "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}mkcd -- ${BASH_FUNK_PREFIX:--}mkcd

function -modified() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... [PATH]\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-modified() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _format _help _selftest _tracecmd _PATH
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... [PATH]"
            echo
            echo "Prints the modification timestamp of the given file or directory."
            echo
            echo "Parameters:"
            echo -e "  \033[1mPATH\033[22m (default: '.', path)"
            echo "      The file or directory to check."
            echo
            echo "Options:"
            echo -e "\033[1m-f, --format FORMAT\033[22m (one of: [locale,iso8601,human])"
            echo "        Prints the timestamp in the given format."
            echo "    -----------------------------"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --format|-f)
            _format="@@##@@"
            __optionWithValue=format
         ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               format)
                  _format=$__arg
                  __optionWithValue=
                 ;;
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      if [[ ! $_PATH && ${#__params[@]} > 0 ]]; then
         _PATH=$__param
         continue
      fi
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ ! $_PATH ]]; then _PATH="."; fi
   if [[ $_format ]]; then
      if [[ $_format == "@@##@@" ]]; then echo "$__fn: Error: Value FORMAT for option --format must be specified."; return 64; fi
      if [[ $_format != 'locale' && $_format != 'iso8601' && $_format != 'human' ]]; then echo "$__fn: Error: Value '$_format' for option --format is not one of the allowed values [locale,iso8601,human]."; return 64; fi
   fi

   if [[ $_PATH ]]; then
      if [[ ! -e "$_PATH" ]]; then echo "$__fn: Error: Path '$_PATH' for parameter PATH does not exist."; return 64; fi
   true
      if [[ ! -r "$_PATH" ]]; then echo "$__fn: Error: Path '$_PATH' for parameter PATH is not readable by user '$USER'."; return 64; fi
   fi

####### modified ####### START
[[ $_tracecmd ]] && set -x || true
local _format=${_format:-timestamp}

case $_format in
   human)  find "$_PATH" -maxdepth 0 -printf "%TY.%Tm.%Td %TT %TZ\n" ;;
   locale) find "$_PATH" -maxdepth 0 -printf "%Tc\n" ;;
   timestamp)
      # use stat if available
      if hash stat &>/dev/null; then
         stat -c %Y "$_PATH"

      # use perl if available
      elif hash perl &>/dev/null; then
         perl << EOF
use File::stat;
print stat("$_PATH")->mtime, "\n"
EOF

      # use python as last resort
      else
         python -c "import os, pwd
 print(str(int(os.path.getmtime('$_PATH'))))"
      fi
     ;;
   iso8601)

      # use stat if available
      if hash stat &>/dev/null; then
         local timestamp=$(stat -c %Y "$_PATH")
         date --iso-8601=seconds -d@$timestamp

      # use perl if available
      elif hash perl &>/dev/null; then
         local timestamp=$(perl << EOF
use File::stat;
print stat("$_PATH")->mtime, "\n"
EOF
         )
         date --iso-8601=seconds -d@$timestamp

      # use python as last resort
      else
         python -c "import os, pwd, datetime, time
print(datetime.datetime.fromtimestamp(int(os.path.getmtime('$_PATH'))).isoformat() + time.strftime('%z'))"
      fi
     ;;
esac
[[ $_tracecmd ]] && set +x || true
####### modified ####### END
}
function __complete-modified() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --format -f --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      local prev="${COMP_WORDS[COMP_CWORD-1]}"
      case $prev in
         --format|-f)
            COMPREPLY=($(compgen -o default -W "locale
iso8601
human" -- $curr))
              ;;
         *)
            COMPREPLY=($(compgen -o default -- $curr))
           ;;
      esac
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}modified -- ${BASH_FUNK_PREFIX:--}modified

function -owner() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... [PATH]\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-owner() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _tracecmd _PATH
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... [PATH]"
            echo
            echo "Prints the owner of the given file or directory."
            echo
            echo "Parameters:"
            echo -e "  \033[1mPATH\033[22m (default: '.', path)"
            echo "      The file or directory to check."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      if [[ ! $_PATH && ${#__params[@]} > 0 ]]; then
         _PATH=$__param
         continue
      fi
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ ! $_PATH ]]; then _PATH="."; fi

   if [[ $_PATH ]]; then
      if [[ ! -e "$_PATH" ]]; then echo "$__fn: Error: Path '$_PATH' for parameter PATH does not exist."; return 64; fi
   true
      if [[ ! -r "$_PATH" ]]; then echo "$__fn: Error: Path '$_PATH' for parameter PATH is not readable by user '$USER'."; return 64; fi
   fi

####### owner ####### START
[[ $_tracecmd ]] && set -x || true
# use stat if available
if hash stat &>/dev/null; then
   echo $(stat -c %U "$_PATH")

# use perl if available
elif hash perl &>/dev/null; then
   perl << EOF
use File::stat;
print getpwuid(stat("$_PATH")->uid), "\n"
EOF

# use python as last resort
else
   python -c "import os, pwd
print(pwd.getpwuid(os.stat('$_PATH').st_uid).pw_name)"
fi
[[ $_tracecmd ]] && set +x || true
####### owner ####### END
}
function __complete-owner() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}owner -- ${BASH_FUNK_PREFIX:--}owner

function -realpath() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... [PATH]\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-realpath() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _tracecmd _PATH
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... [PATH]"
            echo
            echo "Prints the normalized path of the given path resolving any symbolic links. The path is not required to exist."
            echo
            echo "Parameters:"
            echo -e "  \033[1mPATH\033[22m (default: '.', path)"
            echo "      The path to normalize."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      if [[ ! $_PATH && ${#__params[@]} > 0 ]]; then
         _PATH=$__param
         continue
      fi
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ ! $_PATH ]]; then _PATH="."; fi

   if [[ $_PATH ]]; then
   true
   fi

####### realpath ####### START
[[ $_tracecmd ]] && set -x || true
# use readlink if available
if hash readlink &>/dev/null; then
   readlink -m "$_PATH"

# use perl if available
elif hash perl &>/dev/null; then
   perl << EOF
use Cwd 'abs_path';
print abs_path('$_PATH'), "\n"
EOF

# use python as last resort
else
   python -c "import os
print(os.path.realpath('$_PATH'))"
fi
[[ $_tracecmd ]] && set +x || true
####### realpath ####### END
}
function __complete-realpath() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}realpath -- ${BASH_FUNK_PREFIX:--}realpath

function -sudo-append() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... FILE_PATH CONTENT\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-sudo-append() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _tracecmd _FILE_PATH _CONTENT
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... FILE_PATH CONTENT"
            echo
            echo "Creates a file with the given content."
            echo
            echo "Requirements:"
            echo "  + Sudo 'tee -a' is required."
            echo
            echo "Parameters:"
            echo -e "  \033[1mFILE_PATH\033[22m (required)"
            echo "      The path to the file to write."
            echo -e "  \033[1mCONTENT\033[22m (required)"
            echo "      The content to append to the file."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            echo "Examples:"
            echo -e "$ \033[1m$__fn /tmp/testfile.cfg 'foo=bar'\033[22m"
            echo -e "Appending to \[/tmp/testfile.cfg\]..."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn /tmp/testfile.cfg 'foo=bar'\033[22m"
            __stdout="$($__fn /tmp/testfile.cfg 'foo=bar')"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^Appending to \[/tmp/testfile.cfg\]...$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [Appending to \[/tmp/testfile.cfg\]...]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      if [[ ! $_FILE_PATH ]]; then
         _FILE_PATH=$__param
         continue
      fi
      if [[ ! $_CONTENT ]]; then
         _CONTENT=$__param
         continue
      fi
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ $_FILE_PATH ]]; then
      true
   else
      echo "$__fn: Error: Parameter FILE_PATH must be specified."; return 64
   fi
   if [[ $_CONTENT ]]; then
      true
   else
      echo "$__fn: Error: Parameter CONTENT must be specified."; return 64
   fi

   if ! hash "sudo" &>/dev/null; then echo "$__fn: Error: Required command 'sudo' not found on this system."; return 64; fi
   if ! sudo -l -- tee -a &>/dev/null; then echo "$__fn: Error: User $USER misses required sudo permission for 'tee -a'"; return 64; fi

####### sudo-append ####### START
[[ $_tracecmd ]] && set -x || true
echo "Appending to [$_FILE_PATH]..."
echo "$_CONTENT" | sudo tee -a "$_FILE_PATH" > /dev/null
[[ $_tracecmd ]] && set +x || true
####### sudo-append ####### END
}
function __complete-sudo-append() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}sudo-append -- ${BASH_FUNK_PREFIX:--}sudo-append

function -sudo-write() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... FILE_PATH OWNER CONTENT\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-sudo-write() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _tracecmd _FILE_PATH _OWNER _CONTENT
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... FILE_PATH OWNER CONTENT"
            echo
            echo "Creates a file with the given content."
            echo
            echo "Requirements:"
            echo "  + Sudo 'sh -c' is required."
            echo "  + Sudo 'sh chown' is required."
            echo
            echo "Parameters:"
            echo -e "  \033[1mFILE_PATH\033[22m (required)"
            echo "      The path to the file to write."
            echo -e "  \033[1mOWNER\033[22m (required)"
            echo "      The owner and group to set."
            echo -e "  \033[1mCONTENT\033[22m (required)"
            echo "      The content to write."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            echo "Examples:"
            echo -e "$ \033[1m$__fn /tmp/testfile.cfg $USER:$GROUP 'foo=bar'\033[22m"
            echo -e "Writing \[/tmp/testfile.cfg\]..."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn /tmp/testfile.cfg $USER:$GROUP 'foo=bar'\033[22m"
            __stdout="$($__fn /tmp/testfile.cfg $USER:$GROUP 'foo=bar')"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^Writing \[/tmp/testfile.cfg\]...$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [Writing \[/tmp/testfile.cfg\]...]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      if [[ ! $_FILE_PATH ]]; then
         _FILE_PATH=$__param
         continue
      fi
      if [[ ! $_OWNER ]]; then
         _OWNER=$__param
         continue
      fi
      if [[ ! $_CONTENT ]]; then
         _CONTENT=$__param
         continue
      fi
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ $_FILE_PATH ]]; then
      true
   else
      echo "$__fn: Error: Parameter FILE_PATH must be specified."; return 64
   fi
   if [[ $_OWNER ]]; then
      true
   else
      echo "$__fn: Error: Parameter OWNER must be specified."; return 64
   fi
   if [[ $_CONTENT ]]; then
      true
   else
      echo "$__fn: Error: Parameter CONTENT must be specified."; return 64
   fi

   if ! hash "sudo" &>/dev/null; then echo "$__fn: Error: Required command 'sudo' not found on this system."; return 64; fi
   if ! sudo -l -- sh -c &>/dev/null; then echo "$__fn: Error: User $USER misses required sudo permission for 'sh -c'"; return 64; fi
   if ! hash "sudo" &>/dev/null; then echo "$__fn: Error: Required command 'sudo' not found on this system."; return 64; fi
   if ! sudo -l -- sh chown &>/dev/null; then echo "$__fn: Error: User $USER misses required sudo permission for 'sh chown'"; return 64; fi

####### sudo-write ####### START
[[ $_tracecmd ]] && set -x || true
echo "Writing [$_FILE_PATH]..."
sudo sh -c "echo '$_CONTENT' > '$_FILE_PATH'" && sudo chown "$_OWNER" "$_FILE_PATH"
[[ $_tracecmd ]] && set +x || true
####### sudo-write ####### END
}
function __complete-sudo-write() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}sudo-write -- ${BASH_FUNK_PREFIX:--}sudo-write

function -tail-reverse() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... FILE\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-tail-reverse() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _unique _lines _help _selftest _tracecmd _FILE
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... FILE"
            echo
            echo "Prints the last N lines of the given text file in reverse order."
            echo
            echo "Parameters:"
            echo -e "  \033[1mFILE\033[22m (required, file)"
            echo "      Path to the file."
            echo
            echo "Options:"
            echo -e "\033[1m-n, --lines N\033[22m (integer: ?-?)"
            echo "        The maximum number of lines to output."
            echo -e "\033[1m-u, --unique\033[22m"
            echo "        Don't print duplicates."
            echo "    -----------------------------"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --unique|-u)
            _unique=1
         ;;

         --lines|-n)
            _lines="@@##@@"
            __optionWithValue=lines
         ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               lines)
                  _lines=$__arg
                  __optionWithValue=
                 ;;
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      if [[ ! $_FILE ]]; then
         _FILE=$__param
         continue
      fi
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ $_lines ]]; then
      if [[ $_lines == "@@##@@" ]]; then echo "$__fn: Error: Value N for option --lines must be specified."; return 64; fi
      if [[ ! "$_lines" =~ ^-?[0-9]*$ ]]; then echo "$__fn: Error: Value '$_lines' for option --lines is not a numeric value."; return 64; fi
   fi

   if [[ $_FILE ]]; then
      if [[ ! -e "$_FILE" ]]; then echo "$__fn: Error: File '$_FILE' for parameter FILE does not exist."; return 64; fi
      if [[ -e "$_FILE" && ! -f "$_FILE" ]]; then echo "$__fn: Error: Path '$_FILE' for parameter FILE is not a file."; return 64; fi
      if [[ ! -r "$_FILE" ]]; then echo "$__fn: Error: File '$_FILE' for parameter FILE is not readable by user '$USER'."; return 64; fi
   else
      echo "$__fn: Error: Parameter FILE must be specified."; return 64
   fi

####### tail-reverse ####### START
[[ $_tracecmd ]] && set -x || true
if [[ $_unique ]]; then
   if [[ $_lines ]]; then
      awk "{lines[len++]=\$0} END {for(i=len-1;i>=0;i--) if (occurrences[lines[i]]++ == 0) { print lines[i]; count++; if (count>=$_lines) break}}" $_FILE
   else
      awk "{lines[len++]=\$0} END {for(i=len-1;i>=0;i--) if (occurrences[lines[i]]++ == 0) print lines[i]}" $_FILE
   fi
 else
   if [[ $_lines ]]; then
      awk "{lines[len++]=\$0} END {for(i=len-1;len-i<=$_lines;i--) print lines[i]}" $_FILE
   else
      awk "{lines[len++]=\$0} END {for(i=len-1;i>=0;i--) print lines[i]}" $_FILE
   fi
fi
[[ $_tracecmd ]] && set +x || true
####### tail-reverse ####### END
}
function __complete-tail-reverse() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --unique -u --lines -n --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}tail-reverse -- ${BASH_FUNK_PREFIX:--}tail-reverse

function -test-all-filesystem() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]...\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-test-all-filesystem() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _tracecmd
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]..."
            echo
            echo "Performs a selftest of all functions of this module by executing each function with option '--selftest'."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

####### test-all-filesystem ####### START
[[ $_tracecmd ]] && set -x || true
${BASH_FUNK_PREFIX:--}abspath --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}cd-down --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}cd-hist --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}cd-up --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}count-words --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}du --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}extract --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}find-up --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}findfiles --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}ll --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}mkcd --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}modified --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}owner --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}realpath --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}sudo-append --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}sudo-write --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}tail-reverse --selftest && echo || return 1
[[ $_tracecmd ]] && set +x || true
####### test-all-filesystem ####### END
}
function __complete-test-all-filesystem() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}test-all-filesystem -- ${BASH_FUNK_PREFIX:--}test-all-filesystem


function -help-filesystem() {
   local p="\033[1m${BASH_FUNK_PREFIX:--}"
   echo -e "${p}abspath [PATH]\033[0m  -  Prints the normalized path of the given path WITHOUT resolving symbolic links. The path is not required to exist."
   echo -e "${p}cd-down [START_AT] DIR_NAME\033[0m  -  Jumps down in the tree of the current directory to the first sub directory found with the given name."
   echo -e "${p}cd-hist [STEPS_OR_DIRNAME]\033[0m  -  Navigates back in the directory history which can be managed via pushd/popd/dirs and is automatically populated if the Bash Funk bash-prompt is installed."
   echo -e "${p}cd-up [LEVEL_OR_PATTERN]\033[0m  -  Navigates up in the current directory tree to the first parent directory found with the given namen or the given number of levels. Bash completion will auto-complete the names of the parent directories."
   echo -e "${p}count-words WORD1 [WORD]...\033[0m  -  Counts the number of occurences of the word(s) in the text read from stdin."
   echo -e "${p}du [PATH]...\033[0m  -  Prints disk usage information."
   echo -e "${p}extract ARCHIVE [TO_DIR]\033[0m  -  Extracts the given archive using the compatible extractor."
   echo -e "${p}find-up FILENAME\033[0m  -  Traverses the directory upward to find the given file."
   echo -e "${p}findfiles [START_PATH] SEARCH_STRING\033[0m  -  Recursively finds all files containing the given string and displays their path."
   echo -e "${p}ll [PATH]...\033[0m  -  Alternative version of 'ls -lt' that prints directories (and sym-links to directories) before files and hidden entries before non-hidden entries."
   echo -e "${p}mkcd PATH\033[0m  -  Creates a directory and changes into it."
   echo -e "${p}modified [PATH]\033[0m  -  Prints the modification timestamp of the given file or directory."
   echo -e "${p}owner [PATH]\033[0m  -  Prints the owner of the given file or directory."
   echo -e "${p}realpath [PATH]\033[0m  -  Prints the normalized path of the given path resolving any symbolic links. The path is not required to exist."
   echo -e "${p}sudo-append FILE_PATH CONTENT\033[0m  -  Creates a file with the given content."
   echo -e "${p}sudo-write FILE_PATH OWNER CONTENT\033[0m  -  Creates a file with the given content."
   echo -e "${p}tail-reverse FILE\033[0m  -  Prints the last N lines of the given text file in reverse order."
   echo -e "${p}test-all-filesystem\033[0m  -  Performs a selftest of all functions of this module by executing each function with option '--selftest'."
}
__BASH_FUNK_FUNCS+=( abspath cd-down cd-hist cd-up count-words du extract find-up findfiles ll mkcd modified owner realpath sudo-append sudo-write tail-reverse test-all-filesystem )
