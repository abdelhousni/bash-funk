#!/usr/bin/env bash
#
# SPDX-FileCopyrightText: Â© Vegard IT GmbH (https://vegardit.com)
# SPDX-License-Identifier: Apache-2.0
#
# @author Sebastian Thomschke, Vegard IT GmbH
# @author Patrick Spielmann, Vegard IT GmbH
#
# THIS FILE IS GENERATED BY BASH-FUNK GENERATOR
#
# documentation: https://github.com/vegardit/bash-funk/tree/main/docs/performance.md
#

function -cpu-count() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]...\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-cpu-count() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _tracecmd
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]..."
            echo
            echo "Prints the number of logical processors."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            echo "Examples:"
            echo -e "$ \033[1m$__fn \033[22m"
            echo "4"
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn \033[22m"
            __stdout="$($__fn )"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^[0-9]+$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [[0-9]+]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

####### cpu-count ####### START
[[ $_tracecmd ]] && set -x || true
[[ $OSTYPE != "darwin"* ]] && grep processor /proc/cpuinfo | wc -l || sysctl -n hw.logicalcpu
[[ $_tracecmd ]] && set +x || true
####### cpu-count ####### END
}
function __complete-cpu-count() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}cpu-count -- ${BASH_FUNK_PREFIX:--}cpu-count

function -cpu-perf() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]...\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-cpu-perf() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _mode _help _selftest _tracecmd
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]..."
            echo
            echo "Performs a CPU speed test using 'openssl speed' utilizing all available processors or 'cryptsetup benchmark' / 'dd' for single threaded tests."
            echo
            echo "Options:"
            echo -e "\033[1m-m, --mode MODE\033[22m (one of: [openssl-aes128,openssl-aes256,openssl-rsa1024,openssl-rsa2048,openssl-rsa4096,cryptsetup-aes128,cryptsetup-aes256,dd-md5sum,dd-sha256sum,dd-sha512sum])"
            echo "        Select the benchmark mode."
            echo "    -----------------------------"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            echo "Examples:"
            echo -e "$ \033[1m$__fn --mode dd-md5sum\033[22m"
            echo "1073741824 bytes (1.1 GB, 1.0 GiB) copied, 2.04484 s, 525 MB/s"
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn --mode dd-md5sum\033[22m"
            __stdout="$($__fn --mode dd-md5sum)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^.+$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [.+]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --mode|-m)
            _mode="@@##@@"
            __optionWithValue=mode
         ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               mode)
                  _mode=$__arg
                  __optionWithValue=
                 ;;
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ $_mode ]]; then
      if [[ $_mode == "@@##@@" ]]; then echo "$__fn: Error: Value MODE for option --mode must be specified."; return 64; fi
      if [[ $_mode != 'openssl-aes128' && $_mode != 'openssl-aes256' && $_mode != 'openssl-rsa1024' && $_mode != 'openssl-rsa2048' && $_mode != 'openssl-rsa4096' && $_mode != 'cryptsetup-aes128' && $_mode != 'cryptsetup-aes256' && $_mode != 'dd-md5sum' && $_mode != 'dd-sha256sum' && $_mode != 'dd-sha512sum' ]]; then echo "$__fn: Error: Value '$_mode' for option --mode is not one of the allowed values [openssl-aes128,openssl-aes256,openssl-rsa1024,openssl-rsa2048,openssl-rsa4096,cryptsetup-aes128,cryptsetup-aes256,dd-md5sum,dd-sha256sum,dd-sha512sum]."; return 64; fi
   fi

####### cpu-perf ####### START
[[ $_tracecmd ]] && set -x || true
local _mode=${_mode:-openssl-rsa1024}
case $_mode in
   openssl-aes*) openssl speed -multi $(${BASH_FUNK_PREFIX:--}cpu-count) aes-${_mode#*aes}-cbc ;;
   openssl-rsa*) openssl speed -multi $(${BASH_FUNK_PREFIX:--}cpu-count) ${_mode#*-} ;;
   cryptsetup-*) cryptsetup benchmark --cipher aes-cbc --key-size ${_mode#cryptsetup-} ;;
   dd-*)
      if ! hash dd &>/dev/null; then
         echo "$__fn: Required command 'dd' is not available."
         return 1
      fi
      if ! hash ${_mode#dd-} &>/dev/null; then
         echo "$__fn: Required command '${_mode#dd-}' is not available."
         return 1
      fi
      [[ $OSTYPE == "darwin"* ]] && local _bs=1m || local _bs=1M
      dd if=/dev/zero bs=$_bs count=1024 2> >(head -3 | tail -1) > >(${_mode#dd-} >/dev/null)
     ;;
esac
[[ $_tracecmd ]] && set +x || true
####### cpu-perf ####### END
}
function __complete-cpu-perf() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --mode -m --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      local prev="${COMP_WORDS[COMP_CWORD-1]}"
      case $prev in
         --mode|-m)
            COMPREPLY=($(compgen -o default -W "openssl-aes128
openssl-aes256
openssl-rsa1024
openssl-rsa2048
openssl-rsa4096
cryptsetup-aes128
cryptsetup-aes256
dd-md5sum
dd-sha256sum
dd-sha512sum" -- $curr))
              ;;
         *)
            COMPREPLY=($(compgen -o default -- $curr))
           ;;
      esac
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}cpu-perf -- ${BASH_FUNK_PREFIX:--}cpu-perf

function -disk-latency() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... [PATH]\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-disk-latency() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _tracecmd _PATH
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... [PATH]"
            echo
            echo "Determines disk latency in milliseconds using 'dd'."
            echo
            echo "Parameters:"
            echo -e "  \033[1mPATH\033[22m (default: '.', directory)"
            echo "      Path where to create the test files."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            echo "Examples:"
            echo -e "$ \033[1m$__fn \033[22m"
            echo "2.34362 ms disk latency on device /dev/xvda2"
            echo -e "$ \033[1m$__fn /tmp\033[22m"
            echo "1.46379 ms disk latency on device /dev/xvda1"
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn \033[22m"
            __stdout="$($__fn )"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^.+$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [.+]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn /tmp\033[22m"
            __stdout="$($__fn /tmp)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^.+$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [.+]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      if [[ ! $_PATH && ${#__params[@]} > 0 ]]; then
         _PATH=$__param
         continue
      fi
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ ! $_PATH ]]; then _PATH="."; fi

   if [[ $_PATH ]]; then
      if [[ ! -e "$_PATH" ]]; then echo "$__fn: Error: Directory '$_PATH' for parameter PATH does not exist."; return 64; fi
      if [[ -e "$_PATH" && ! -d "$_PATH" ]]; then echo "$__fn: Error: Path '$_PATH' for parameter PATH is not a directory."; return 64; fi
      if [[ ! -r "$_PATH" ]]; then echo "$__fn: Error: Directory '$_PATH' for parameter PATH is not readable by user '$USER'."; return 64; fi
      if [[ ! -w "$_PATH" ]]; then echo "$__fn: Error: Directory '$_PATH' for parameter PATH is not writeable by user '$USER'."; return 64; fi
   fi

####### disk-latency ####### START
[[ $_tracecmd ]] && set -x || true
if hash ioping &>/dev/null; then
   ioping -c 1 "$_PATH"
else
   if [[ $OSTYPE == "darwin"* ]]; then
      local testFile="$(mktemp "$_PATH/XXXXXX")"
   else
      local testFile="$(mktemp --tmpdir="$_PATH")"
   fi

   if ! hash dd &>/dev/null; then
      echo "$__fn: Required command 'dd' or 'ioping' is not available."
      return 1
   fi
   local ddResult
   if ddResult=$(set -o pipefail; dd if=/dev/zero "of=$testFile" bs=512 count=1000 oflag=dsync 2>&1 | tail -1 | sed -E 's/.*copied, ([0-9.]+) .+/\1 ms/'); then
      rm "$testFile"
      echo "$ddResult disk latency on device $(df -P "$_PATH" | tail -1 | cut -d' ' -f1)"
      return 0
   else
      rm "$testFile"
      echo $ddResult
      return 1
   fi
fi
[[ $_tracecmd ]] && set +x || true
####### disk-latency ####### END
}
function __complete-disk-latency() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}disk-latency -- ${BASH_FUNK_PREFIX:--}disk-latency

function -disk-perf() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... [PATH]\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-disk-perf() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _mode _size _help _selftest _tracecmd _PATH
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... [PATH]"
            echo
            echo "Performs a I/O speed test using 'fio' utilizing all available processors or single-threaded using 'dd'."
            echo
            echo "Parameters:"
            echo -e "  \033[1mPATH\033[22m (default: '.', directory)"
            echo "      Path where to create the test files."
            echo
            echo "Options:"
            echo -e "\033[1m-m, --mode MODE\033[22m (one of: [dd,fio])"
            echo "        Select the benchmark mode."
            echo -e "\033[1m    --size SIZE\033[22m (integer: 1-?)"
            echo "        Test file size in MB (Default is 2048MB)."
            echo "    -----------------------------"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            echo "Examples:"
            echo -e "$ \033[1m$__fn --mode dd --size 2\033[22m"
            echo "Testing single-threaded sequential write performance...
2097152 bytes (2.1 MB, 2.0 MiB) copied, 0.0186709 s, 112 MB/s

Testing single-threaded sequential read performance...
2097152 bytes (2.1 MB, 2.0 MiB) copied, 0.00332485 s, 631 MB/s"
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn --mode dd --size 2\033[22m"
            __stdout="$($__fn --mode dd --size 2)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^.+$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [.+]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --mode|-m)
            _mode="@@##@@"
            __optionWithValue=mode
         ;;

         --size)
            _size="@@##@@"
            __optionWithValue=size
         ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               mode)
                  _mode=$__arg
                  __optionWithValue=
                 ;;
               size)
                  _size=$__arg
                  __optionWithValue=
                 ;;
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      if [[ ! $_PATH && ${#__params[@]} > 0 ]]; then
         _PATH=$__param
         continue
      fi
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ ! $_PATH ]]; then _PATH="."; fi
   if [[ $_mode ]]; then
      if [[ $_mode == "@@##@@" ]]; then echo "$__fn: Error: Value MODE for option --mode must be specified."; return 64; fi
      if [[ $_mode != 'dd' && $_mode != 'fio' ]]; then echo "$__fn: Error: Value '$_mode' for option --mode is not one of the allowed values [dd,fio]."; return 64; fi
   fi
   if [[ $_size ]]; then
      if [[ $_size == "@@##@@" ]]; then echo "$__fn: Error: Value SIZE for option --size must be specified."; return 64; fi
      if [[ ! "$_size" =~ ^-?[0-9]*$ ]]; then echo "$__fn: Error: Value '$_size' for option --size is not a numeric value."; return 64; fi
      if [[ $_size -lt 1 ]]; then echo "$__fn: Error: Value '$_size' for option --size is too low. Must be >= 1."; return 64; fi
   fi

   if [[ $_PATH ]]; then
      if [[ ! -e "$_PATH" ]]; then echo "$__fn: Error: Directory '$_PATH' for parameter PATH does not exist."; return 64; fi
      if [[ -e "$_PATH" && ! -d "$_PATH" ]]; then echo "$__fn: Error: Path '$_PATH' for parameter PATH is not a directory."; return 64; fi
      if [[ ! -r "$_PATH" ]]; then echo "$__fn: Error: Directory '$_PATH' for parameter PATH is not readable by user '$USER'."; return 64; fi
      if [[ ! -w "$_PATH" ]]; then echo "$__fn: Error: Directory '$_PATH' for parameter PATH is not writeable by user '$USER'."; return 64; fi
   fi

####### disk-perf ####### START
[[ $_tracecmd ]] && set -x || true
local _size=${_size:-2048}
local _mode=${_mode:-fio}
case $_mode in
   dd)
      if ! hash dd &>/dev/null; then
         echo "$__fn: Required command 'dd' is not available."
         return 1
      fi
      if [[ $OSTYPE == "darwin"* ]]; then
         local testFile=$(mktemp "$_PATH/XXXXXX")
      else
         local testFile=$(mktemp --tmpdir="$_PATH")
      fi
      echo "Testing single-threaded sequential write performance..."
      dd if=/dev/zero of="${testFile}" bs=1M count=${_size} conv=fdatasync 2>&1 | head -3 | tail -1
      echo
      echo "Testing single-threaded sequential read performance..."
      dd if="${testFile}" of=/dev/null bs=4k 2>&1 | head -3 | tail -1
      rm $testFile
     ;;
   *) if ! hash fio &>/dev/null; then
         echo "$__fn: Required command 'fio' is not available. You can also try with option '--mode dd'."
         return 1
      fi
      if [[ $OSTYPE == "darwin"* ]]; then
         local testFile=$(basename $(mktemp -u "$_PATH/XXXXXX"))
      else
         local testFile=$(basename $(mktemp --dry-run --tmpdir="$_PATH"))
      fi
      echo "Testing multi-threaded random write performance..."
      fio --randrepeat=1 --ioengine=libaio --direct=1 --gtod_reduce=1 --directory="$_PATH" --numjobs $(${BASH_FUNK_PREFIX:--}cpu-count) --name=$testFile --bs=4k --iodepth=64 --size=${_size}M --readwrite=randwrite
      echo
      echo "Testing multi-threaded random read performance..."
      fio --randrepeat=1 --ioengine=libaio --direct=1 --gtod_reduce=1 --directory="$_PATH" --numjobs $(${BASH_FUNK_PREFIX:--}cpu-count) --name=$testFile --bs=4k --iodepth=64 --size=${_size}M --readwrite=randread
      echo
      echo "Testing multi-threaded random read-write (3:1) performance..."
      fio --randrepeat=1 --ioengine=libaio --direct=1 --gtod_reduce=1 --directory="$_PATH" --numjobs $(${BASH_FUNK_PREFIX:--}cpu-count) --name=$testFile --bs=4k --iodepth=64 --size=${_size}M --readwrite=randrw --rwmixread=75
     ;;
esac
[[ $_tracecmd ]] && set +x || true
####### disk-perf ####### END
}
function __complete-disk-perf() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --mode -m --size --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      local prev="${COMP_WORDS[COMP_CWORD-1]}"
      case $prev in
         --mode|-m)
            COMPREPLY=($(compgen -o default -W "dd
fio" -- $curr))
              ;;
         *)
            COMPREPLY=($(compgen -o default -- $curr))
           ;;
      esac
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}disk-perf -- ${BASH_FUNK_PREFIX:--}disk-perf

function -scp-perf() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... TARGET [SIZE_MB]\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-scp-perf() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _port _identity_file _help _selftest _tracecmd _TARGET _SIZE_MB
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... TARGET [SIZE_MB]"
            echo
            echo "Performs an SCP speed test."
            echo
            echo "Parameters:"
            echo -e "  \033[1mTARGET\033[22m (required)"
            echo "      [user@:]hostname."
            echo -e "  \033[1mSIZE_MB\033[22m (default: '10', integer: ?-?)"
            echo "      Test file size in MB."
            echo
            echo "Options:"
            echo -e "\033[1m-i, --identity_file PATH\033[22m (file)"
            echo "        Path to the private key for public key authentication."
            echo -e "\033[1m-P, --port PORT\033[22m (integer: 0-65535)"
            echo "        Ssh port."
            echo "    -----------------------------"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --port|-P)
            _port="@@##@@"
            __optionWithValue=port
         ;;

         --identity_file|-i)
            _identity_file="@@##@@"
            __optionWithValue=identity_file
         ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               port)
                  _port=$__arg
                  __optionWithValue=
                 ;;
               identity_file)
                  _identity_file=$__arg
                  __optionWithValue=
                 ;;
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      if [[ ! $_TARGET ]]; then
         _TARGET=$__param
         continue
      fi
      if [[ ! $_SIZE_MB ]]; then
         _SIZE_MB=$__param
         continue
      fi
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ ! $_SIZE_MB ]]; then _SIZE_MB="10"; fi
   if [[ $_port ]]; then
      if [[ $_port == "@@##@@" ]]; then echo "$__fn: Error: Value PORT for option --port must be specified."; return 64; fi
      if [[ ! "$_port" =~ ^-?[0-9]*$ ]]; then echo "$__fn: Error: Value '$_port' for option --port is not a numeric value."; return 64; fi
      if [[ $_port -lt 0 ]]; then echo "$__fn: Error: Value '$_port' for option --port is too low. Must be >= 0."; return 64; fi
      if [[ $_port -gt 65535 ]]; then echo "$__fn: Error: Value '$_port' for option --port is too high. Must be <= 65535."; return 64; fi
   fi
   if [[ $_identity_file ]]; then
      if [[ $_identity_file == "@@##@@" ]]; then echo "$__fn: Error: Value PATH for option --identity_file must be specified."; return 64; fi
      if [[ ! -e "$_identity_file" ]]; then echo "$__fn: Error: File '$_identity_file' for option --identity_file does not exist."; return 64; fi
      if [[ -e "$_identity_file" && ! -f "$_identity_file" ]]; then echo "$__fn: Error: Path '$_identity_file' for option --identity_file is not a file."; return 64; fi
      if [[ ! -r "$_identity_file" ]]; then echo "$__fn: Error: File '$_identity_file' for option --identity_file is not readable by user '$USER'."; return 64; fi
   fi

   if [[ $_TARGET ]]; then
      true
   else
      echo "$__fn: Error: Parameter TARGET must be specified."; return 64
   fi
   if [[ $_SIZE_MB ]]; then
      if [[ ! "$_SIZE_MB" =~ ^-?[0-9]*$ ]]; then echo "$__fn: Error: Value '$_SIZE_MB' for parameter SIZE_MB is not a numeric value."; return 64; fi
   fi

####### scp-perf ####### START
[[ $_tracecmd ]] && set -x || true
local dataFile=$(mktemp)

local sshOpts=""
if [[ ${_port} ]]; then
   sshOpts="$sshOpts -P $_port"
fi
if [[ ${_identity_file} ]]; then
   sshOpts="$sshOpts -i $_identity_file"
fi

local _SIZE_MB=${_SIZE_MB:-10}

echo "Generating $_SIZE_MB MB of random data..."
dd if=/dev/urandom bs=1M count=$_SIZE_MB of=$dataFile conv=notrunc

echo
echo "Uploading $_SIZE_MB MB to $_TARGET..."
scp $sshOpts "$dataFile" "$_TARGET:${dataFile}-copy"

echo
echo "Downloading $_SIZE_MB MB from $_TARGET..."
scp $sshOpts "$_TARGET:${dataFile}-copy" "$dataFile"

echo
echo "Removing test data on $_TARGET..."
ssh $sshOpts "$_TARGET" "rm ${dataFile}-copy"
echo "Removing local test data..."
rm $dataFile
[[ $_tracecmd ]] && set +x || true
####### scp-perf ####### END
}
function __complete-scp-perf() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --port -P --identity_file -i --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}scp-perf -- ${BASH_FUNK_PREFIX:--}scp-perf

function -test-all-performance() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]...\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-test-all-performance() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _tracecmd
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]..."
            echo
            echo "Performs a selftest of all functions of this module by executing each function with option '--selftest'."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

####### test-all-performance ####### START
[[ $_tracecmd ]] && set -x || true
${BASH_FUNK_PREFIX:--}cpu-count --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}cpu-perf --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}disk-latency --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}disk-perf --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}scp-perf --selftest && echo || return 1
[[ $_tracecmd ]] && set +x || true
####### test-all-performance ####### END
}
function __complete-test-all-performance() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}test-all-performance -- ${BASH_FUNK_PREFIX:--}test-all-performance


function -help-performance() {
   local p="\033[1m${BASH_FUNK_PREFIX:--}"
   echo -e "${p}cpu-count\033[0m  -  Prints the number of logical processors."
   echo -e "${p}cpu-perf\033[0m  -  Performs a CPU speed test using 'openssl speed' utilizing all available processors or 'cryptsetup benchmark' / 'dd' for single threaded tests."
   echo -e "${p}disk-latency [PATH]\033[0m  -  Determines disk latency in milliseconds using 'dd'."
   echo -e "${p}disk-perf [PATH]\033[0m  -  Performs a I/O speed test using 'fio' utilizing all available processors or single-threaded using 'dd'."
   echo -e "${p}scp-perf TARGET [SIZE_MB]\033[0m  -  Performs an SCP speed test."
   echo -e "${p}test-all-performance\033[0m  -  Performs a selftest of all functions of this module by executing each function with option '--selftest'."
}
__BASH_FUNK_FUNCS+=( cpu-count cpu-perf disk-latency disk-perf scp-perf test-all-performance )
