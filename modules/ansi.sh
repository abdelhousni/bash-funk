#!/usr/bin/env bash
#
# SPDX-FileCopyrightText: Â© Vegard IT GmbH (https://vegardit.com)
# SPDX-License-Identifier: Apache-2.0
#
# @author Sebastian Thomschke, Vegard IT GmbH
# @author Patrick Spielmann, Vegard IT GmbH
#
# THIS FILE IS GENERATED BY BASH-FUNK GENERATOR
#
# documentation: https://github.com/vegardit/bash-funk/tree/main/docs/ansi.md
#

function -ansi-alternate() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... [ANSI_SEQUENCE]...\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-ansi-alternate() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _color _skip _help _selftest _tracecmd _ANSI_SEQUENCE=()
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... [ANSI_SEQUENCE]..."
            echo
            echo "Alternately colorizes the line read from stdin. If stdout is no terminal highlighting is disabled automatically."
            echo
            echo "Parameters:"
            echo -e "  \033[1mANSI_SEQUENCE\033[22m"
            echo -e "      ANSI escape sequence used for every n-th row, defaults to' '\\\033[35m'."
            echo
            echo "Options:"
            echo -e "\033[1m    --color [WHEN]\033[22m (default: 'auto', one of: [always,auto,never])"
            echo "        Indicates when to colorize the output."
            echo -e "\033[1m    --skip LINES\033[22m (integer: 0-?)"
            echo "        Do not colorize the first N lines."
            echo "    -----------------------------"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            echo "Examples:"
            echo -e "$ \033[1m echo -e 'line1\\\nline2\\\nline3\\\nline4' | ${BASH_FUNK_PREFIX:--}ansi-alternate\033[22m"
            echo
            echo -e "$ \033[1m echo -e 'line1\\\nline2\\\nline3\\\nline4' | ${BASH_FUNK_PREFIX:--}ansi-alternate '\\\033[31m'\033[22m"
            echo
            echo -e "$ \033[1m echo -e 'line1\\\nline2\\\nline3\\\nline4' | ${BASH_FUNK_PREFIX:--}ansi-alternate '\\\033[31m' '\\\033[32m'\033[22m"
            echo
            echo -e "$ \033[1m echo -e 'line1\\\nline2\\\nline3\\\nline4' | ${BASH_FUNK_PREFIX:--}ansi-alternate '\\\033[31m' '\\\033[32m' '\\\033[33m'\033[22m"
            echo
            echo -e "$ \033[1m echo -e 'line1\\\nline2\\\nline3\\\nline4' | ${BASH_FUNK_PREFIX:--}ansi-alternate '\\\033[31m' --skip 3\033[22m"
            echo
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --color)
            _color="auto"
            __optionWithValue=color
         ;;

         --skip)
            _skip="@@##@@"
            __optionWithValue=skip
         ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               color)
                  _color=$__arg
                  __optionWithValue=
                 ;;
               skip)
                  _skip=$__arg
                  __optionWithValue=
                 ;;
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      _ANSI_SEQUENCE+=("$__param")
      continue
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ $_color ]]; then
      if [[ $_color == "@@##@@" ]]; then echo "$__fn: Error: Value WHEN for option --color must be specified."; return 64; fi
      if [[ $_color != 'always' && $_color != 'auto' && $_color != 'never' ]]; then echo "$__fn: Error: Value '$_color' for option --color is not one of the allowed values [always,auto,never]."; return 64; fi
   fi
   if [[ $_skip ]]; then
      if [[ $_skip == "@@##@@" ]]; then echo "$__fn: Error: Value LINES for option --skip must be specified."; return 64; fi
      if [[ ! "$_skip" =~ ^-?[0-9]*$ ]]; then echo "$__fn: Error: Value '$_skip' for option --skip is not a numeric value."; return 64; fi
      if [[ $_skip -lt 0 ]]; then echo "$__fn: Error: Value '$_skip' for option --skip is too low. Must be >= 0."; return 64; fi
   fi

####### ansi-alternate ####### START
[[ $_tracecmd ]] && set -x || true
# check if stdin is opend on terminal (and thus not on a pipe)
if [[ -t 0 ]]; then
   return 0
fi

local colorize
case "${_color:-auto}" in
   always) colorize=1 ;;
   never) colorize=0 ;;
   auto)
      if ${BASH_FUNK_PREFIX:--}ansi-colors-supported 8 && [[ -t 1 ]]; then
         colorize=1
      else
         colorize=0
      fi
esac

if [[ $colorize == 1 ]]; then
   local ansi_sequences_count=${#_ANSI_SEQUENCE[@]}
   if (( ansi_sequences_count == 0 )); then
      _ANSI_SEQUENCE=( '\033[35m' '' )
      ansi_sequences_count=2
   elif (( ansi_sequences_count == 1 )); then
      _ANSI_SEQUENCE=( "${_ANSI_SEQUENCE[0]}" '' )
      ansi_sequences_count=2
   fi

   local line line_no=0 skip=${_skip:0}
   while IFS='$\n' read -r line; do
      (( line_no++ ))
      if (( line_no > skip )); then
         echo -ne "${_ANSI_SEQUENCE[$(( ( (line_no - skip) - 1) % ansi_sequences_count ))]}"
         echo -n "$line"
         echo -e "\033[0m"
      else
         echo "$line"
      fi
   done
else
   local line
   while IFS='$\n' read -r line; do
      echo "$line"
   done
fi
[[ $_tracecmd ]] && set +x || true
####### ansi-alternate ####### END
}
function __complete-ansi-alternate() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --color --skip --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      local prev="${COMP_WORDS[COMP_CWORD-1]}"
      case $prev in
         --color)
            COMPREPLY=($(compgen -o default -W "always
auto
never" -- $curr))
              ;;
         *)
            COMPREPLY=($(compgen -o default -- $curr))
           ;;
      esac
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}ansi-alternate -- ${BASH_FUNK_PREFIX:--}ansi-alternate

function -ansi-bold() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... [TEXT]\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-ansi-bold() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _on _off _help _selftest _tracecmd _TEXT
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... [TEXT]"
            echo
            echo "Sets bold mode or prints the given text in bold."
            echo
            echo "Parameters:"
            echo -e "  \033[1mTEXT\033[22m"
            echo "      The text to print in bold."
            echo
            echo "Options:"
            echo -e "\033[1m    --off\033[22m"
            echo "        Print the ANSI escape sequence that disables sets bold attribute."
            echo -e "\033[1m    --on\033[22m"
            echo "        Print the ANSI escape sequence that enables sets bold attribute."
            echo "    -----------------------------"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --on)
            _on=1
         ;;

         --off)
            _off=1
         ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      if [[ ! $_TEXT && ${#__params[@]} > 0 ]]; then
         _TEXT=$__param
         continue
      fi
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

####### ansi-bold ####### START
[[ $_tracecmd ]] && set -x || true
if [[ $_TEXT ]]; then
   echo -ne "\033[1m$_TEXT\033[22m"
fi

if [[ $_on ]]; then
   echo -ne "\033[1m"
elif [[ $_off ]]; then
   echo -ne "\033[22m"
fi
[[ $_tracecmd ]] && set +x || true
####### ansi-bold ####### END
}
function __complete-ansi-bold() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --on --off --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}ansi-bold -- ${BASH_FUNK_PREFIX:--}ansi-bold

function -ansi-codes() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... [PREFIX]\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-ansi-codes() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _escape _help _selftest _tracecmd _PREFIX
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... [PREFIX]"
            echo
            echo "Prints commands to set variables with common ANSI codes. When used with the 'echo' command, the -e option is not required."
            echo
            echo "Parameters:"
            echo -e "  \033[1mPREFIX\033[22m (default: 'ANSI_')"
            echo "      Prefix to be used for the declared variables."
            echo
            echo "Options:"
            echo -e "\033[1m-e, --escape\033[22m"
            echo "        If specified the escape code will be printed as octal value ."
            echo "    -----------------------------"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --escape|-e)
            _escape=1
         ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      if [[ ! $_PREFIX && ${#__params[@]} > 0 ]]; then
         _PREFIX=$__param
         continue
      fi
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ ! $_PREFIX ]]; then _PREFIX="ANSI_"; fi

####### ansi-codes ####### START
[[ $_tracecmd ]] && set -x || true
if [[ $_escape ]]; then
   local ESC="\033";
else
   local ESC=$(echo -e "\033");
fi

echo "
${_PREFIX}RESET=\"$ESC[0m\"
${_PREFIX}BOLD=\"$ESC[1m\"
${_PREFIX}BOLD_OFF=\"$ESC[22m\"
${_PREFIX}ITALIC=\"$ESC[3m\"
${_PREFIX}UNDERLINE=\"$ESC[4m\"
${_PREFIX}UNDERLINE_DOUBLE=\"$ESC[21m\"
${_PREFIX}UNDERLINE_OFF=\"$ESC[24m\"
${_PREFIX}BLINK_SLOW=\"$ESC[5m\"
${_PREFIX}BLINK_FAST=\"$ESC[6m\"
${_PREFIX}BLINK_OFF=\"$ESC[25m\"
${_PREFIX}INVERT=\"$ESC[7m\"
${_PREFIX}INVERT_OFF=\"$ESC[27m\"

${_PREFIX}FG_BLACK=\"$ESC[30m\"
${_PREFIX}FG_RED=\"$ESC[31m\"
${_PREFIX}FG_GREEN=\"$ESC[32m\"
${_PREFIX}FG_YELLOW=\"$ESC[33m\"
${_PREFIX}FG_BLUE=\"$ESC[34m\"
${_PREFIX}FG_MAGENTA=\"$ESC[35m\"
${_PREFIX}FG_CYAN=\"$ESC[36m\"
${_PREFIX}FG_GRAY=\"$ESC[37m\"

${_PREFIX}FG_LIGHT_RED=\"$ESC[91m\"
${_PREFIX}FG_LIGHT_GREEN=\"$ESC[92m\"
${_PREFIX}FG_LIGHT_YELLOW=\"$ESC[93m\"
${_PREFIX}FG_LIGHT_BLUE=\"$ESC[94m\"
${_PREFIX}FG_LIGHT_MAGENTA=\"$ESC[95m\"
${_PREFIX}FG_LIGHT_CYAN=\"$ESC[96m\"
${_PREFIX}FG_WHITE=\"$ESC[97m\"

${_PREFIX}BG_BLACK=\"$ESC[40m\"
${_PREFIX}BG_RED=\"$ESC[41m\"
${_PREFIX}BG_GREEN=\"$ESC[42m\"
${_PREFIX}BG_YELLOW=\"$ESC[43m\"
${_PREFIX}BG_BLUE=\"$ESC[44m\"
${_PREFIX}BG_MAGENTA=\"$ESC[45m\"
${_PREFIX}BG_CYAN=\"$ESC[46m\"
${_PREFIX}BG_GRAY=\"$ESC[47m\"

${_PREFIX}BG_LIGHT_BLACK=\"$ESC[100m\"
${_PREFIX}BG_LIGHT_RED=\"$ESC[101m\"
${_PREFIX}BG_LIGHT_GREEN=\"$ESC[102m\"
${_PREFIX}BG_LIGHT_YELLOW=\"$ESC[103m\"
${_PREFIX}BG_LIGHT_BLUE=\"$ESC[104m\"
${_PREFIX}BG_LIGHT_MAGENTA=\"$ESC[105m\"
${_PREFIX}BG_LIGHT_CYAN=\"$ESC[106m\"
${_PREFIX}BG_WHITE=\"$ESC[107m\"
"
[[ $_tracecmd ]] && set +x || true
####### ansi-codes ####### END
}
function __complete-ansi-codes() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --escape -e --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}ansi-codes -- ${BASH_FUNK_PREFIX:--}ansi-codes

function -ansi-colors-supported() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... [NUM_COLORS]\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-ansi-colors-supported() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _tracecmd _verbose _NUM_COLORS
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... [NUM_COLORS]"
            echo
            echo "Determines if the given number of ANSI colors is supported by the current terminal. If NUM_COLORS is specified, the exit value indicates if the color range is supported. If NUM_COLORS is not specified, the number of supported colors is printed with exit code 0."
            echo
            echo "Parameters:"
            echo -e "  \033[1mNUM_COLORS\033[22m"
            echo "      Number of colors that need to be supported."
            echo
            echo "Options:"
            echo -e "\033[1m-v, --verbose\033[22m"
            echo "        Prints additional information during command execution."
            echo "    -----------------------------"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            echo "Examples:"
            echo -e "$ \033[1m$__fn \033[22m"
            echo "256"
            echo -e "$ \033[1m$__fn -v 8\033[22m"
            echo "Terminal 'xterm' supports 8 colors."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn \033[22m"
            __stdout="$($__fn )"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^[0-9]+$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [[0-9]+]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn -v 8\033[22m"
            __stdout="$($__fn -v 8)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^Terminal '.*' supports [0-9]+ colors.$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [Terminal '.*' supports [0-9]+ colors.]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --verbose|-v)
            _verbose=1
         ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      if [[ ! $_NUM_COLORS && ${#__params[@]} > 0 ]]; then
         _NUM_COLORS=$__param
         continue
      fi
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

####### ansi-colors-supported ####### START
[[ $_tracecmd ]] && set -x || true
local numColors
if hash tput &>/dev/null; then
   numColors=$(tput colors)
elif hash infocmp &>/dev/null; then
   local termInfo=$(infocmp $TERM || true);
   if [[ $termInfo =~ colors#([0-9]+), ]]; then
      local numColors=${BASH_REMATCH[1]}
   else
      numColors=-1
   fi
elif [[ $TERM == "cygwin" ]]; then
   numColors=8
else
   numColors=-1
fi

if [[ $_NUM_COLORS ]]; then
   if [[ $numColors -ge $_NUM_COLORS ]]; then
      [[ $_verbose ]] && echo "Terminal '$TERM' supports $numColors colors."
      return 0
   else
      [[ $_verbose ]] && echo "Terminal '$TERM' supports only $numColors colors."
      return 1
   fi
else
   echo $numColors
   return 0
fi
[[ $_tracecmd ]] && set +x || true
####### ansi-colors-supported ####### END
}
function __complete-ansi-colors-supported() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help --tracecmd --verbose -v "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}ansi-colors-supported -- ${BASH_FUNK_PREFIX:--}ansi-colors-supported

function -ansi-colors16() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]...\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-ansi-colors16() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _tracecmd
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]..."
            echo
            echo "Prints a table with 8/16 ANSI colors."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

####### ansi-colors16 ####### START
[[ $_tracecmd ]] && set -x || true
if ! ${BASH_FUNK_PREFIX:--}ansi-colors-supported 8; then
   echo "WARNING: Your current terminal '$TERM' is reported to not support displaying 8 colors."
   echo
elif ! ${BASH_FUNK_PREFIX:--}ansi-colors-supported 16; then
   echo "WARNING: Your current terminal '$TERM' is reported to not support displaying 16 colors."
   echo
fi

echo "To set one of the following color combinations use '\033[<BG>;<FG>m'"
echo
echo -n "      "
for fg in {30..37} 39 {90..97}; do
   printf "  FG %2d" "$fg"
done
echo
for bg in {40..47} 49 {100..107}; do
   printf "BG %3d " "$bg"
   for fg in {30..37} 39 {90..97}; do
      printf "\033[${bg};${fg}m%3d;%2d\033[0m " "$bg" "$fg"
   done
   echo
done
[[ $_tracecmd ]] && set +x || true
####### ansi-colors16 ####### END
}
function __complete-ansi-colors16() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}ansi-colors16 -- ${BASH_FUNK_PREFIX:--}ansi-colors16

function -ansi-colors256() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]...\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-ansi-colors256() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _tracecmd
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]..."
            echo
            echo "Prints a table with 256 ANSI colors."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

####### ansi-colors256 ####### START
[[ $_tracecmd ]] && set -x || true
if ! ${BASH_FUNK_PREFIX:--}ansi-colors-supported 256; then
   echo "WARNING: Your current terminal '$TERM' is reported to not support displaying 256 colors."
   echo
fi

# this function is inspired by https://github.com/Evanlec/config/blob/master/bin/256colors2.pl

local i green red blue spacer

printf "To set one of the following \033[1mforeground\033[0m colors use '\\\033[38;5;\033[1m<NUM>\033[0mm'\n"
echo
echo "System Colors:"
for (( i=0; i<16; i++));do
   if (( i == 0 )); then
      printf "\033[48;5;231m"
   else
      printf "\033[48;5;0m"
   fi
   printf "\033[38;5;${i}m%2d \033[0m" "$i"
done
echo
echo
echo "Color Cubes 6x6x6:"
for (( green=0; green<6; green++ )) {
   for (( red=0; red<6; red++ )) {
      for (( blue=0; blue<6; blue++ )) {
         i=$(( 16 + 36*red + 6*green + blue ))
         if (( (i - 16) % 6 == 0)); then
            spacer=""
         else
            spacer=" "
         fi
         if (( i > 87 )); then
            printf "\033[38;5;${i}m$spacer%3d\033[0m" "$i"
         else
            printf "\033[38;5;${i}m$spacer%2d\033[0m" "$i"
         fi
      }
      printf "\033[38;5;8m|\033[0m"
   }
   echo
}
echo
echo "Grayscale Ramp:"
for i in 16 {232..255} 231;do
   if (( i == 16 || i > 231 && i < 234 )); then
      printf "\033[48;5;236m"
   else
      printf "\033[48;5;0m"
   fi
   printf "\033[38;5;${i}m%3d \033[0m" "$i"
done
echo

echo
echo
printf "To set one of the following \033[1mbackground\033[0m colors use '\\\033[48;5;\033[1m<NUM>\033[0mm'\n"
echo
echo "System Colors:"
for (( i=0; i<16; i++));do
   if (( i == 0 )); then
      printf "\033[48;5;231m"
   else
      printf "\033[48;5;0m"
   fi
   printf "\033[48;5;${i}m%2d \033[0m" "$i"
done
echo
echo
echo "Color Cubes 6x6x6:"
for (( green=0; green<6; green++ )) {
   for (( red=0; red<6; red++ )) {
      for (( blue=0; blue<6; blue++ )) {
         i=$(( 16 + 36*red + 6*green + blue ))
         if (( (i - 16) % 6 == 0)); then
            spacer=""
         else
            spacer=" "
         fi
         if (( i > 87 )); then
            printf "\033[38;5;235;48;5;${i}m$spacer%3d\033[0m" "$i"
         else
            printf "\033[38;5;235;48;5;${i}m$spacer%2d\033[0m" "$i"
         fi
      }
      printf " "
   }
   echo
}
echo
echo "Grayscale Ramp:"
for i in 16 {232..255} 231;do
   if (( i == 231 )); then
      printf "\033[38;5;254m"
   else
      printf "\033[38;5;15m"
   fi
   printf "\033[48;5;${i}m%3d \033[0m" "$i"
done
echo
[[ $_tracecmd ]] && set +x || true
####### ansi-colors256 ####### END
}
function __complete-ansi-colors256() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}ansi-colors256 -- ${BASH_FUNK_PREFIX:--}ansi-colors256

function -ansi-reset() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]...\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-ansi-reset() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _tracecmd
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]..."
            echo
            echo "Prints an ANSI escape sequence that reset all ANSI attributes."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

####### ansi-reset ####### START
[[ $_tracecmd ]] && set -x || true
echo -ne "\033[0m"
[[ $_tracecmd ]] && set +x || true
####### ansi-reset ####### END
}
function __complete-ansi-reset() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}ansi-reset -- ${BASH_FUNK_PREFIX:--}ansi-reset

function -ansi-ul() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... [TEXT]\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-ansi-ul() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _on _off _help _selftest _tracecmd _TEXT
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... [TEXT]"
            echo
            echo "Sets underlined mode or prints the given text underlined."
            echo
            echo "Parameters:"
            echo -e "  \033[1mTEXT\033[22m"
            echo "      The text to print underlined."
            echo
            echo "Options:"
            echo -e "\033[1m    --off\033[22m"
            echo "        Print the ANSI escape sequence that disables sets underlined attribute."
            echo -e "\033[1m    --on\033[22m"
            echo "        Print the ANSI escape sequence that enables sets underlined attribute."
            echo "    -----------------------------"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --on)
            _on=1
         ;;

         --off)
            _off=1
         ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      if [[ ! $_TEXT && ${#__params[@]} > 0 ]]; then
         _TEXT=$__param
         continue
      fi
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

####### ansi-ul ####### START
[[ $_tracecmd ]] && set -x || true
if [[ $_TEXT ]]; then
   echo -ne "\033[4m$_TEXT\033[24m"
fi

if [[ $_on ]]; then
   echo -ne "\033[4m"
elif [[ $_off ]]; then
   echo -ne "\033[24m"
fi
[[ $_tracecmd ]] && set +x || true
####### ansi-ul ####### END
}
function __complete-ansi-ul() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --on --off --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}ansi-ul -- ${BASH_FUNK_PREFIX:--}ansi-ul

function -cursor-pos() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]...\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-cursor-pos() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _save _restore _up _down _left _right _assign _set _print _fd _help _selftest _tracecmd
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]..."
            echo
            echo "Performs ANSI cursor operations."
            echo
            echo "Options:"
            echo -e "\033[1m    --assign VARNAME\033[22m"
            echo "        Assigns the current cursor position to the variable with the given name."
            echo -e "\033[1m-d, --down [LINES]\033[22m (default: '1', integer: ?-?)"
            echo "        Moves the cursor n lines down."
            echo -e "\033[1m    --fd [NUM]\033[22m (default: '1', integer: ?-?)"
            echo "        Send the ANSI sequences to the given file descriptor."
            echo -e "\033[1m-l, --left [COLUMNS]\033[22m (default: '1', integer: ?-?)"
            echo "        Move the cursor n columns forward."
            echo -e "\033[1m    --print\033[22m"
            echo "        Prints the current cursor position."
            echo -e "\033[1m    --restore\033[22m"
            echo "        Restores the last saved cursor position."
            echo -e "\033[1m-r, --right [COLUMNS]\033[22m (default: '1', integer: ?-?)"
            echo "        Move the cursor n columns backward."
            echo -e "\033[1m    --save\033[22m"
            echo "        Saves the current cursor position."
            echo -e "\033[1m    --set ROW_AND_COL\033[22m"
            echo "        Sets the cursor position (ROW:COL)."
            echo -e "\033[1m-u, --up [LINES]\033[22m (default: '1', integer: ?-?)"
            echo "        Moves the cursor n lines up."
            echo "    -----------------------------"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --save)
            _save=1
         ;;

         --restore)
            _restore=1
         ;;

         --up|-u)
            _up="1"
            __optionWithValue=up
         ;;

         --down|-d)
            _down="1"
            __optionWithValue=down
         ;;

         --left|-l)
            _left="1"
            __optionWithValue=left
         ;;

         --right|-r)
            _right="1"
            __optionWithValue=right
         ;;

         --assign)
            _assign="@@##@@"
            __optionWithValue=assign
         ;;

         --set)
            _set="@@##@@"
            __optionWithValue=set
         ;;

         --print)
            _print=1
         ;;

         --fd)
            _fd="1"
            __optionWithValue=fd
         ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               up)
                  _up=$__arg
                  __optionWithValue=
                 ;;
               down)
                  _down=$__arg
                  __optionWithValue=
                 ;;
               left)
                  _left=$__arg
                  __optionWithValue=
                 ;;
               right)
                  _right=$__arg
                  __optionWithValue=
                 ;;
               assign)
                  _assign=$__arg
                  __optionWithValue=
                 ;;
               set)
                  _set=$__arg
                  __optionWithValue=
                 ;;
               fd)
                  _fd=$__arg
                  __optionWithValue=
                 ;;
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ $_up ]]; then
      if [[ $_up == "@@##@@" ]]; then echo "$__fn: Error: Value LINES for option --up must be specified."; return 64; fi
      if [[ ! "$_up" =~ ^-?[0-9]*$ ]]; then echo "$__fn: Error: Value '$_up' for option --up is not a numeric value."; return 64; fi
   fi
   if [[ $_down ]]; then
      if [[ $_down == "@@##@@" ]]; then echo "$__fn: Error: Value LINES for option --down must be specified."; return 64; fi
      if [[ ! "$_down" =~ ^-?[0-9]*$ ]]; then echo "$__fn: Error: Value '$_down' for option --down is not a numeric value."; return 64; fi
   fi
   if [[ $_left ]]; then
      if [[ $_left == "@@##@@" ]]; then echo "$__fn: Error: Value COLUMNS for option --left must be specified."; return 64; fi
      if [[ ! "$_left" =~ ^-?[0-9]*$ ]]; then echo "$__fn: Error: Value '$_left' for option --left is not a numeric value."; return 64; fi
   fi
   if [[ $_right ]]; then
      if [[ $_right == "@@##@@" ]]; then echo "$__fn: Error: Value COLUMNS for option --right must be specified."; return 64; fi
      if [[ ! "$_right" =~ ^-?[0-9]*$ ]]; then echo "$__fn: Error: Value '$_right' for option --right is not a numeric value."; return 64; fi
   fi
   if [[ $_assign ]]; then
      if [[ $_assign == "@@##@@" ]]; then echo "$__fn: Error: Value VARNAME for option --assign must be specified."; return 64; fi
   fi
   if [[ $_set ]]; then
      if [[ $_set == "@@##@@" ]]; then echo "$__fn: Error: Value ROW_AND_COL for option --set must be specified."; return 64; fi
   fi
   if [[ $_fd ]]; then
      if [[ $_fd == "@@##@@" ]]; then echo "$__fn: Error: Value NUM for option --fd must be specified."; return 64; fi
      if [[ ! "$_fd" =~ ^-?[0-9]*$ ]]; then echo "$__fn: Error: Value '$_fd' for option --fd is not a numeric value."; return 64; fi
   fi

####### cursor-pos ####### START
[[ $_tracecmd ]] && set -x || true
if [[ $_save ]]; then
   echo -en "\033[s" >&$_fd
fi

if [[ $_restore ]]; then
   echo -en "\033[u" >&$_fd
fi

if [[ $_up ]]; then
   echo -en "\033[${_up}A" >&$_fd
fi

if [[ $_down ]]; then
   echo -en "\033[${_down}B" >&$_fd
fi

if [[ $_right ]]; then
   echo -en "\033[${_right}C" >&$_fd
fi

if [[ $_left ]]; then
   echo -en "\033[${_left}D" >&$_fd
fi

if [[ $_set ]]; then
   echo -en "\033[${_set//:/;}H" >&$_fd
fi

if [[ $_print || $_assign ]]; then
   local pos
   echo -en "\E[6n" && read -sdR pos >&$_fd
   pos=${pos#*[}
   pos=${pos//;/:}
   if [[ $_print ]]; then
      echo $pos >&$_fd
   fi
   if [[ $_assign ]]; then
      eval "$_assign=\"$pos\""
    fi
fi
[[ $_tracecmd ]] && set +x || true
####### cursor-pos ####### END
}
function __complete-cursor-pos() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --save --restore --up -u --down -d --left -l --right -r --assign --set --print --fd --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}cursor-pos -- ${BASH_FUNK_PREFIX:--}cursor-pos

function -test-all-ansi() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]...\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-test-all-ansi() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _tracecmd
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]..."
            echo
            echo "Performs a selftest of all functions of this module by executing each function with option '--selftest'."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

####### test-all-ansi ####### START
[[ $_tracecmd ]] && set -x || true
${BASH_FUNK_PREFIX:--}ansi-alternate --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}ansi-bold --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}ansi-codes --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}ansi-colors-supported --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}ansi-colors16 --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}ansi-colors256 --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}ansi-reset --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}ansi-ul --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}cursor-pos --selftest && echo || return 1
[[ $_tracecmd ]] && set +x || true
####### test-all-ansi ####### END
}
function __complete-test-all-ansi() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}test-all-ansi -- ${BASH_FUNK_PREFIX:--}test-all-ansi


function -help-ansi() {
   local p="\033[1m${BASH_FUNK_PREFIX:--}"
   echo -e "${p}ansi-alternate [ANSI_SEQUENCE]...\033[0m  -  Alternately colorizes the line read from stdin. If stdout is no terminal highlighting is disabled automatically."
   echo -e "${p}ansi-bold [TEXT]\033[0m  -  Sets bold mode or prints the given text in bold."
   echo -e "${p}ansi-codes [PREFIX]\033[0m  -  Prints commands to set variables with common ANSI codes. When used with the 'echo' command, the -e option is not required."
   echo -e "${p}ansi-colors-supported [NUM_COLORS]\033[0m  -  Determines if the given number of ANSI colors is supported by the current terminal. If NUM_COLORS is specified, the exit value indicates if the color range is supported. If NUM_COLORS is not specified, the number of supported colors is printed with exit code 0."
   echo -e "${p}ansi-colors16\033[0m  -  Prints a table with 8/16 ANSI colors."
   echo -e "${p}ansi-colors256\033[0m  -  Prints a table with 256 ANSI colors."
   echo -e "${p}ansi-reset\033[0m  -  Prints an ANSI escape sequence that reset all ANSI attributes."
   echo -e "${p}ansi-ul [TEXT]\033[0m  -  Sets underlined mode or prints the given text underlined."
   echo -e "${p}cursor-pos\033[0m  -  Performs ANSI cursor operations."
   echo -e "${p}test-all-ansi\033[0m  -  Performs a selftest of all functions of this module by executing each function with option '--selftest'."
}
__BASH_FUNK_FUNCS+=( ansi-alternate ansi-bold ansi-codes ansi-colors-supported ansi-colors16 ansi-colors256 ansi-reset ansi-ul cursor-pos test-all-ansi )
