#!/usr/bin/env bash
#
# SPDX-FileCopyrightText: Â© Vegard IT GmbH (https://vegardit.com)
# SPDX-License-Identifier: Apache-2.0
#
# @author Sebastian Thomschke, Vegard IT GmbH
# @author Patrick Spielmann, Vegard IT GmbH
#
# THIS FILE IS GENERATED BY BASH-FUNK GENERATOR
#
# documentation: https://github.com/vegardit/bash-funk/tree/main/docs/math.md
#

function -calc() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... [FORMULA]...\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-calc() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _round _help _selftest _tracecmd _FORMULA=()
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... [FORMULA]..."
            echo
            echo "Performs calculations using awk. See https://www.gnu.org/software/gawk/manual/html_node/Arithmetic-Ops.html."
            echo
            echo "Requirements:"
            echo "  + Command 'awk' must be available."
            echo
            echo "Parameters:"
            echo -e "  \033[1mFORMULA\033[22m"
            echo "      The formula to calculate."
            echo
            echo "Options:"
            echo -e "\033[1m    --round PRECISION\033[22m (integer: 0-?)"
            echo "        Rounds the value with the given precision."
            echo "    -----------------------------"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            echo "Examples:"
            echo -e "$ \033[1m$__fn 1.103+1.203\033[22m"
            echo "2.306"
            echo -e "$ \033[1m$__fn 1.103+1.203 --round 2\033[22m"
            echo "2.31"
            echo -e "$ \033[1m$__fn 1.109-0.8 --round 2\033[22m"
            echo "0.31"
            echo -e "$ \033[1m$__fn 1.109-0.8 --round 1\033[22m"
            echo "0.3"
            echo -e "$ \033[1m$__fn 1.109-0.8 --round 0\033[22m"
            echo "0"
            echo -e "$ \033[1m$__fn 2^1.2 --round 1\033[22m"
            echo "2.3"
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 1.103+1.203\033[22m"
            __stdout="$($__fn 1.103+1.203)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^2.306$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [2.306]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 1.103+1.203 --round 2\033[22m"
            __stdout="$($__fn 1.103+1.203 --round 2)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^2.31$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [2.31]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 1.109-0.8 --round 2\033[22m"
            __stdout="$($__fn 1.109-0.8 --round 2)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^0.31$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [0.31]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 1.109-0.8 --round 1\033[22m"
            __stdout="$($__fn 1.109-0.8 --round 1)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^0.3$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [0.3]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 1.109-0.8 --round 0\033[22m"
            __stdout="$($__fn 1.109-0.8 --round 0)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^0$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 2^1.2 --round 1\033[22m"
            __stdout="$($__fn 2^1.2 --round 1)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^2.3$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [2.3]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --round)
            _round="@@##@@"
            __optionWithValue=round
         ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               round)
                  _round=$__arg
                  __optionWithValue=
                 ;;
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      _FORMULA+=("$__param")
      continue
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ $_round ]]; then
      if [[ $_round == "@@##@@" ]]; then echo "$__fn: Error: Value PRECISION for option --round must be specified."; return 64; fi
      if [[ ! "$_round" =~ ^-?[0-9]*$ ]]; then echo "$__fn: Error: Value '$_round' for option --round is not a numeric value."; return 64; fi
      if [[ $_round -lt 0 ]]; then echo "$__fn: Error: Value '$_round' for option --round is too low. Must be >= 0."; return 64; fi
   fi

   if ! hash "awk" &>/dev/null; then echo "$__fn: Error: Required command 'awk' not found on this system."; return 64; fi

####### calc ####### START
[[ $_tracecmd ]] && set -x || true
if [[ ! ${_FORMULA:-} ]]; then
   "$__fn: Formula is missing."
   return 1
fi

local formula=""
for part in "${_FORMULA[@]}"; do
   formula="$formula $part"
done

if [[ ${_round:-} ]]; then
   LC_ALL=C awk "BEGIN{printf \"%.${_round}f\n\", ($formula)}"
else
   LC_ALL=C awk "BEGIN{print ($formula)}"
fi
[[ $_tracecmd ]] && set +x || true
####### calc ####### END
}
function __complete-calc() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --round --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}calc -- ${BASH_FUNK_PREFIX:--}calc

function -round() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... VALUE PRECISION\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-round() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _tracecmd _VALUE _PRECISION
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... VALUE PRECISION"
            echo
            echo "Rounds the given decimal value using 'printf' builtin.."
            echo
            echo "Parameters:"
            echo -e "  \033[1mVALUE\033[22m (required, pattern: \"[-+]?[0-9]*\.?[0-9]+\")"
            echo "      The first number."
            echo -e "  \033[1mPRECISION\033[22m (required, integer: 0-?)"
            echo "      Number of decimal digits."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            echo "Examples:"
            echo -e "$ \033[1m$__fn 1.903 3\033[22m"
            echo "1.903"
            echo -e "$ \033[1m$__fn 1.903 2\033[22m"
            echo "1.90"
            echo -e "$ \033[1m$__fn 1.903 0\033[22m"
            echo "2"
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 1.903 3\033[22m"
            __stdout="$($__fn 1.903 3)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^1.903$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [1.903]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 1.903 2\033[22m"
            __stdout="$($__fn 1.903 2)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^1.90$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [1.90]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 1.903 0\033[22m"
            __stdout="$($__fn 1.903 0)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^2$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [2]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      if [[ ! $_VALUE ]]; then
         _VALUE=$__param
         continue
      fi
      if [[ ! $_PRECISION ]]; then
         _PRECISION=$__param
         continue
      fi
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ $_VALUE ]]; then
      if [[ ! "$_VALUE" =~ ^[-+]?[0-9]*\.?[0-9]+$ ]]; then echo "$__fn: Error: Value '$_VALUE' for parameter VALUE does not match required pattern '[-+]?[0-9]*\.?[0-9]+'."; return 64; fi
   else
      echo "$__fn: Error: Parameter VALUE must be specified."; return 64
   fi
   if [[ $_PRECISION ]]; then
      if [[ ! "$_PRECISION" =~ ^-?[0-9]*$ ]]; then echo "$__fn: Error: Value '$_PRECISION' for parameter PRECISION is not a numeric value."; return 64; fi
      if [[ $_PRECISION -lt 0 ]]; then echo "$__fn: Error: Value '$_PRECISION' for parameter PRECISION is too low. Must be >= 0."; return 64; fi
   else
      echo "$__fn: Error: Parameter PRECISION must be specified."; return 64
   fi

####### round ####### START
[[ $_tracecmd ]] && set -x || true
LC_ALL=C builtin printf "%.*f\n" $_PRECISION $_VALUE
[[ $_tracecmd ]] && set +x || true
####### round ####### END
}
function __complete-round() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}round -- ${BASH_FUNK_PREFIX:--}round

function -simple-calc() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]... FORMULA\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-simple-calc() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _round _using _help _selftest _tracecmd _FORMULA
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]... FORMULA"
            echo
            echo "Performs simple floating point operations using awk, perl, python or bc - depending on which command is available."
            echo
            echo "Parameters:"
            echo -e "  \033[1mFORMULA\033[22m (required, pattern: \"[+-]?[0-9]*\.?[0-9]+[/*^+-][0-9]*\.?[0-9]+\")"
            echo "      The formula in the form of <NUM><OPERATOR><NUM>."
            echo
            echo "Options:"
            echo -e "\033[1m    --round PRECISION\033[22m (integer: 0-?)"
            echo "        Rounds the value with the given precision."
            echo -e "\033[1m    --using COMMAND\033[22m (one of: [awk,bc,perl,python])"
            echo "        Specifies which command to use for calculation."
            echo "    -----------------------------"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            echo "Examples:"
            echo -e "$ \033[1m$__fn 1.103+1.203\033[22m"
            echo "2.306"
            echo -e "$ \033[1m$__fn 1.103+1.203 --round 2\033[22m"
            echo "2.31"
            echo -e "$ \033[1m$__fn 1.109-0.8 --round 2\033[22m"
            echo "0.31"
            echo -e "$ \033[1m$__fn 1.109-0.8 --round 1\033[22m"
            echo "0.3"
            echo -e "$ \033[1m$__fn 1.109-0.8 --round 0\033[22m"
            echo "0"
            echo -e "$ \033[1m$__fn 2^1.2 --round 1\033[22m"
            echo "2.3"
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 1.103+1.203\033[22m"
            __stdout="$($__fn 1.103+1.203)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^2.306$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [2.306]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 1.103+1.203 --using awk\033[22m"
            __stdout="$($__fn 1.103+1.203 --using awk)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^2.306$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [2.306]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 1.103+1.203 --using bc\033[22m"
            __stdout="$($__fn 1.103+1.203 --using bc)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^2.306$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [2.306]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 1.103+1.203 --using perl\033[22m"
            __stdout="$($__fn 1.103+1.203 --using perl)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^2.306$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [2.306]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 1.103+1.203 --using python\033[22m"
            __stdout="$($__fn 1.103+1.203 --using python)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^2.306$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [2.306]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 1.103+1.203 --round 2\033[22m"
            __stdout="$($__fn 1.103+1.203 --round 2)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^2.31$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [2.31]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 1.103+1.203 --round 2 --using awk\033[22m"
            __stdout="$($__fn 1.103+1.203 --round 2 --using awk)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^2.31$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [2.31]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 1.103+1.203 --round 2 --using bc\033[22m"
            __stdout="$($__fn 1.103+1.203 --round 2 --using bc)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^2.31$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [2.31]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 1.103+1.203 --round 2 --using perl\033[22m"
            __stdout="$($__fn 1.103+1.203 --round 2 --using perl)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^2.31$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [2.31]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 1.103+1.203 --round 2 --using python\033[22m"
            __stdout="$($__fn 1.103+1.203 --round 2 --using python)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^2.31$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [2.31]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 1.109-0.8 --round 2\033[22m"
            __stdout="$($__fn 1.109-0.8 --round 2)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^0.31$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [0.31]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 1.109-0.8 --round 2 --using awk\033[22m"
            __stdout="$($__fn 1.109-0.8 --round 2 --using awk)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^0.31$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [0.31]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 1.109-0.8 --round 2 --using bc\033[22m"
            __stdout="$($__fn 1.109-0.8 --round 2 --using bc)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^0.31$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [0.31]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 1.109-0.8 --round 2 --using perl\033[22m"
            __stdout="$($__fn 1.109-0.8 --round 2 --using perl)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^0.31$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [0.31]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 1.109-0.8 --round 2 --using python\033[22m"
            __stdout="$($__fn 1.109-0.8 --round 2 --using python)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^0.31$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [0.31]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 1.109-0.8 --round 1\033[22m"
            __stdout="$($__fn 1.109-0.8 --round 1)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^0.3$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [0.3]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 1.109-0.8 --round 1 --using awk\033[22m"
            __stdout="$($__fn 1.109-0.8 --round 1 --using awk)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^0.3$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [0.3]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 1.109-0.8 --round 1 --using bc\033[22m"
            __stdout="$($__fn 1.109-0.8 --round 1 --using bc)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^0.3$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [0.3]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 1.109-0.8 --round 1 --using perl\033[22m"
            __stdout="$($__fn 1.109-0.8 --round 1 --using perl)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^0.3$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [0.3]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 1.109-0.8 --round 1 --using python\033[22m"
            __stdout="$($__fn 1.109-0.8 --round 1 --using python)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^0.3$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [0.3]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 1.109-0.8 --round 0\033[22m"
            __stdout="$($__fn 1.109-0.8 --round 0)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^0$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 1.109-0.8 --round 0 --using awk\033[22m"
            __stdout="$($__fn 1.109-0.8 --round 0 --using awk)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^0$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 1.109-0.8 --round 0 --using bc\033[22m"
            __stdout="$($__fn 1.109-0.8 --round 0 --using bc)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^0$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 1.109-0.8 --round 0 --using perl\033[22m"
            __stdout="$($__fn 1.109-0.8 --round 0 --using perl)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^0$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 1.109-0.8 --round 0 --using python\033[22m"
            __stdout="$($__fn 1.109-0.8 --round 0 --using python)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^0$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 2^1.2 --round 1\033[22m"
            __stdout="$($__fn 2^1.2 --round 1)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^2.3$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [2.3]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 2^1.2 --round 1 --using awk\033[22m"
            __stdout="$($__fn 2^1.2 --round 1 --using awk)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^2.3$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [2.3]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 2^1.2 --round 1 --using bc\033[22m"
            __stdout="$($__fn 2^1.2 --round 1 --using bc)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^2.3$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [2.3]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 2^1.2 --round 1 --using perl\033[22m"
            __stdout="$($__fn 2^1.2 --round 1 --using perl)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^2.3$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [2.3]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo -e "$ \033[1m$__fn 2^1.2 --round 1 --using python\033[22m"
            __stdout="$($__fn 2^1.2 --round 1 --using python)"; __rc=$?
            echo "$__stdout"
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            __regex="^2.3$"
            if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [2.3]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --round)
            _round="@@##@@"
            __optionWithValue=round
         ;;

         --using)
            _using="@@##@@"
            __optionWithValue=using
         ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               round)
                  _round=$__arg
                  __optionWithValue=
                 ;;
               using)
                  _using=$__arg
                  __optionWithValue=
                 ;;
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      if [[ ! $_FORMULA ]]; then
         _FORMULA=$__param
         continue
      fi
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

   if [[ $_round ]]; then
      if [[ $_round == "@@##@@" ]]; then echo "$__fn: Error: Value PRECISION for option --round must be specified."; return 64; fi
      if [[ ! "$_round" =~ ^-?[0-9]*$ ]]; then echo "$__fn: Error: Value '$_round' for option --round is not a numeric value."; return 64; fi
      if [[ $_round -lt 0 ]]; then echo "$__fn: Error: Value '$_round' for option --round is too low. Must be >= 0."; return 64; fi
   fi
   if [[ $_using ]]; then
      if [[ $_using == "@@##@@" ]]; then echo "$__fn: Error: Value COMMAND for option --using must be specified."; return 64; fi
      if [[ $_using != 'awk' && $_using != 'bc' && $_using != 'perl' && $_using != 'python' ]]; then echo "$__fn: Error: Value '$_using' for option --using is not one of the allowed values [awk,bc,perl,python]."; return 64; fi
   fi

   if [[ $_FORMULA ]]; then
      if [[ ! "$_FORMULA" =~ ^[+-]?[0-9]*\.?[0-9]+[/*^+-][0-9]*\.?[0-9]+$ ]]; then echo "$__fn: Error: Value '$_FORMULA' for parameter FORMULA does not match required pattern '[+-]?[0-9]*\.?[0-9]+[/*^+-][0-9]*\.?[0-9]+'."; return 64; fi
   else
      echo "$__fn: Error: Parameter FORMULA must be specified."; return 64
   fi

####### simple-calc ####### START
[[ $_tracecmd ]] && set -x || true
if [[ $_FORMULA =~ ^([+-]?[0-9]*\.?[0-9]+)([/*^+-])([0-9]*\.?[0-9]+)$ ]]; then
   local leftNumber=${BASH_REMATCH[1]}
   local operator=${BASH_REMATCH[2]}
   local rightNumber=${BASH_REMATCH[3]}
else
   echo "$_fn: Invalid formula."
   return 1
fi

if [[ ! ${_using:-} ]]; then
   if hash awk &>/dev/null; then
      local _using=awk
   elif hash perl &>/dev/null; then
      local _using=perl
   elif hash python &>/dev/null; then
      local _using=python
   elif hash bc &>/dev/null; then
      local _using=bc
   else
      echo "$_fn: No supported command for floating operations available."
      return 1
   fi
fi

case $_using in

   awk)
      if [[ ${_round:-} ]]; then
         LC_ALL=C awk "BEGIN{printf \"%.${_round}f\n\", $leftNumber$operator$rightNumber}"
      else
         LC_ALL=C awk "BEGIN{print $leftNumber$operator$rightNumber}"
      fi
     ;;
   bc)
      if [[ ${_round:-} ]]; then
         # https://stackoverflow.com/questions/16164925/using-fractional-exponent-with-bc
         if [[ $operator == "^" && $rightNumber == *.* ]]; then
            LC_ALL=C builtin printf "%.${_round}f\n" $(bc -l <<< "e($rightNumber*l($leftNumber))")
         else
            LC_ALL=C builtin printf "%.${_round}f\n" $(bc -l <<< "$leftNumber$operator$rightNumber")
         fi
      else
         # https://stackoverflow.com/questions/16164925/using-fractional-exponent-with-bc
         if [[ $operator == "^" && $rightNumber == *.* ]]; then
            LC_ALL=C bc -l <<< "e($rightNumber*l($leftNumber))"
         else
            LC_ALL=C bc -l <<< "$leftNumber$operator$rightNumber"
         fi
      fi
     ;;
   perl)
      if [[ ${_round:-} ]]; then
         if [[ $operator == "^" ]]; then
            LC_ALL=C perl <<< "printf(\"%.${_round}f\", $leftNumber ** $rightNumber)"
         else
            LC_ALL=C perl <<< "printf(\"%.${_round}f\", $leftNumber $operator $rightNumber)"
         fi
      else
         if [[ $operator == "^" ]]; then
            LC_ALL=C perl <<< "print $leftNumber ** $rightNumber"
         else
            LC_ALL=C perl <<< "print $leftNumber $operator $rightNumber"
         fi
      fi
     ;;
   python)
      LC_ALL=C python -c "import math
if '$operator' == '^':
   result=math.pow($leftNumber, $rightNumber)
else:
   result=$leftNumber $operator $rightNumber

if ${_round:--1} > -1:
   result=round(result, ${_round:-0})

result=str(result)

if result.endswith('.0'):
   result=result[:-2]

print(result)
"
    ;;
esac
[[ $_tracecmd ]] && set +x || true
####### simple-calc ####### END
}
function __complete-simple-calc() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --round --using --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      local prev="${COMP_WORDS[COMP_CWORD-1]}"
      case $prev in
         --using)
            COMPREPLY=($(compgen -o default -W "awk
bc
perl
python" -- $curr))
              ;;
         *)
            COMPREPLY=($(compgen -o default -- $curr))
           ;;
      esac
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}simple-calc -- ${BASH_FUNK_PREFIX:--}simple-calc

function -test-all-math() {
   if [[ "$-" == *x* ]]; then set +x; local opts="set -x"; else local opts=""; fi

   local opt rc __fn=${FUNCNAME[0]}
   for opt in a u H t; do
      [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
   done
   shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
   for opt in nullglob extglob nocasematch nocaseglob; do
      shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
   done

   set +auHtx -o pipefail

   local _ps4=$PS4
   PS4='+\033[90m[$?] $BASH_SOURCE:$LINENO ${FUNCNAME[0]}()\033[0m '
   __impl$__fn "$@" && rc=0 || rc=$?
   PS4=$_ps4

   if [[ $rc == 64 && -t 1 ]]; then
      echo -e "\nUsage: $__fn [OPTION]...\n\nType '$__fn --help' for more details."
   fi
   eval $opts
   return $rc
}
function __impl-test-all-math() {
   local __args=() __arg __idx __noMoreFlags __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _tracecmd
   [ -t 1 ] && __interactive=1 || true
         for __arg in "$@"; do
         case "$__arg" in
            --) __noMoreFlags=1; __args+=("--") ;;
            -|--*) __args+=("$__arg") ;;
            -*) [[ $__noMoreFlags == "1" ]] && __args+=("$__arg") || for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
         esac
      done
   for __arg in "${__args[@]}"; do
      if [[ $__optionWithValue == "--" ]]; then
         __params+=("$__arg")
         continue
      fi
      case "$__arg" in

         --help)
            echo "Usage: $__fn [OPTION]..."
            echo
            echo "Performs a selftest of all functions of this module by executing each function with option '--selftest'."
            echo
            echo "Options:"
            echo -e "\033[1m    --help\033[22m"
            echo "        Prints this help."
            echo -e "\033[1m    --tracecmd\033[22m"
            echo "        Enables bash debug mode (set -x)."
            echo -e "\033[1m    --selftest\033[22m"
            echo "        Performs a self-test."
            echo -e "    \033[1m--\033[22m"
            echo "        Terminates the option list."
            echo
            return 0
           ;;

         --selftest)
            echo "Testing function [$__fn]..."
            echo -e "$ \033[1m$__fn --help\033[22m"
            local __stdout __rc
            __stdout="$($__fn --help)"; __rc=$?
            if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
            echo -e "--> \033[32mOK\033[0m"
            echo "Testing function [$__fn]...DONE"
            return 0
           ;;

         --tracecmd) _tracecmd=1 ;;

         --)
            __optionWithValue="--"
           ;;
         -*)
            echo "$__fn: invalid option: '$__arg'"
            return 64
           ;;

         *)
            case $__optionWithValue in
               *)
                  __params+=("$__arg")
            esac
           ;;
      esac
   done

   for __param in "${__params[@]}"; do
      echo "$__fn: Error: too many parameters: '$__param'"
      return 64
   done

####### test-all-math ####### START
[[ $_tracecmd ]] && set -x || true
${BASH_FUNK_PREFIX:--}calc --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}round --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}simple-calc --selftest && echo || return 1
[[ $_tracecmd ]] && set +x || true
####### test-all-math ####### END
}
function __complete-test-all-math() {
   local curr=${COMP_WORDS[COMP_CWORD]}
   if [[ ${curr} == -* ]]; then
      local options=" --help --tracecmd "
      for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
      COMPREPLY=($(compgen -o default -W '$options' -- $curr))
   else
      COMPREPLY=($(compgen -o default -- $curr))
   fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}test-all-math -- ${BASH_FUNK_PREFIX:--}test-all-math


function -help-math() {
   local p="\033[1m${BASH_FUNK_PREFIX:--}"
   echo -e "${p}calc [FORMULA]...\033[0m  -  Performs calculations using awk. See https://www.gnu.org/software/gawk/manual/html_node/Arithmetic-Ops.html."
   echo -e "${p}round VALUE PRECISION\033[0m  -  Rounds the given decimal value using 'printf' builtin.."
   echo -e "${p}simple-calc FORMULA\033[0m  -  Performs simple floating point operations using awk, perl, python or bc - depending on which command is available."
   echo -e "${p}test-all-math\033[0m  -  Performs a selftest of all functions of this module by executing each function with option '--selftest'."
}
__BASH_FUNK_FUNCS+=( calc round simple-calc test-all-math )
